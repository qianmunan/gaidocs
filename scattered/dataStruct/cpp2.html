<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简单再次复习一下 C++ | 小锅盖儿</title>
    <meta name="description" content="一站式的 Ros2 内容解释平台">
    <link rel="preload stylesheet" href="/assets/style.db7adfca.css" as="style">
    <script type="module" src="/assets/app.5fb56b3a.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/assets/chunks/framework.055571f3.js">
  <link rel="modulepreload" href="/assets/chunks/theme.3b61530b.js">
  <link rel="modulepreload" href="/assets/scattered_dataStruct_cpp2.md.8688c2c8.lean.js">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="keywords" content="Ros、Matlab、无人驾驶、自动导航、coding、github">
  <meta name="author" content="小锅盖儿">
  <meta property="og:type" content="article">
  <meta name="application-name" content="小锅盖儿">
  <meta name="apple-mobile-web-app-title" content="小锅盖儿">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="shortcut icon" href="https://photohosting.oss-cn-hangzhou.aliyuncs.com/captures/grinning-face-with-big-eyes_1f603.png">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="mask-icon" href="" color="#06f">
  <meta name="theme-color" content="#06f">
  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
  <link rel="preconnect" crossorigin="anonymous" href="https://fonts.googleapis.com">
  <link rel="preconnect" crossorigin="anonymous" href="https://fonts.gstatic.com">
  <meta property="og:description" content="一站式的 Ros2 内容解释平台">
  <meta property="og:url" content="https://www.fwenqian.com">
  <meta property="og:locale" content="zh_CN">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css" crossorigin="">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-b2cf3e0b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8616af1></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8616af1> Skip to content </a><!--]--><!----><header class="VPNav" data-v-b2cf3e0b data-v-7e5bc4a5><div class="VPNavBar has-sidebar" data-v-7e5bc4a5 data-v-94c81dcc><div class="container" data-v-94c81dcc><div class="title" data-v-94c81dcc><div class="VPNavBarTitle has-sidebar" data-v-94c81dcc data-v-f4ef19a3><a class="title" href="/" data-v-f4ef19a3><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo4.png" alt data-v-6db2186b><!--]--><!--[-->小锅盖儿<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-94c81dcc><div class="curtain" data-v-94c81dcc></div><div class="content-body" data-v-94c81dcc><!--[--><!--]--><div class="VPNavBarSearch search" data-v-94c81dcc><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><span class="DocSearch-Button-Key">Meta</span><span class="DocSearch-Button-Key">K</span></span></button></div></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-94c81dcc data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/articles/" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->首页<!--]--><!----></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 专栏 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/ros/" data-v-d2c93bab data-v-8f4dc553><!--[-->Ros2<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/matlab/" data-v-d2c93bab data-v-8f4dc553><!--[-->Matlab<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/scattered/" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->杂记<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/project/" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->项目<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/download/" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->资源导航<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-94c81dcc data-v-f6a63727><label title="toggle dark mode" data-v-f6a63727 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-94c81dcc data-v-0394ad82 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/qianmunan" aria-label="github" target="_blank" rel="noopener" data-v-f6988cfb data-v-c530cc0a><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-94c81dcc data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>外观</p><div class="appearance-action" data-v-40855f84><label title="toggle dark mode" data-v-40855f84 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/qianmunan" aria-label="github" target="_blank" rel="noopener" data-v-f6988cfb data-v-c530cc0a><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-94c81dcc data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav" data-v-b2cf3e0b data-v-392e1bf8><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-392e1bf8><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-392e1bf8><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-392e1bf8>归档</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-392e1bf8 data-v-079b16a8><button data-v-079b16a8>返回顶部</button><!----></div></div><aside class="VPSidebar" data-v-b2cf3e0b data-v-af16598e><div class="curtain" data-v-af16598e></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-af16598e><span class="visually-hidden" id="sidebar-aria-label" data-v-af16598e> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-af16598e><section class="VPSidebarItem level-0" data-v-af16598e data-v-c4656e6d><!----><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>📕 导读</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 collapsible has-active" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>数据结构与算法</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-c4656e6d><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-c4656e6d><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>简介</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link is-active has-active" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/cpp2" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>复习c++</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/concept" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据结构基本概念</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/Linear" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>线性表</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/array" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数组和矩阵</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/stack" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>栈</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/queue" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>队列</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/string" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>串</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数组和广义表</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/tree" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>树和二叉树</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>图</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/dataStruct/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>查找</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><p class="text" data-v-c4656e6d>内部排序</p><!----></div><!----></div><div class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><p class="text" data-v-c4656e6d>算法设计与分析</p><!----></div><!----></div><div class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><p class="text" data-v-c4656e6d>贪婪算法</p><!----></div><!----></div><div class="VPSidebarItem level-1" data-v-c4656e6d data-v-c4656e6d><div class="item" role="button" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><p class="text" data-v-c4656e6d>分而治之</p><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 collapsible collapsed" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>软考中级软件设计师</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-c4656e6d><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-c4656e6d><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>简介</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>计算机组成与体系结构</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/operatingsystem" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>操作系统基本原理</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/database" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据库系统</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/net" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>计算机网络</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据结构与算法</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/cpp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>程序设计语言</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/regulations" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>法律法规</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/standardization" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>标准化</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/multimedia" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>多媒体基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>软件工程</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>面向对象</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据流程图</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据库设计</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>UML建模</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>数据结构与算法应用</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/softtest/computercom" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>面向对象程序设计</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 collapsible collapsed" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>HCIA（华为数通初级认证）</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-c4656e6d><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-c4656e6d><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutIp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>网络概述</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutRoute" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>VRP基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutSwitche" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>TCP/IP协议</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutVlan" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>交换</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutStp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>交换机工作原理</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutPPP" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>VLAN</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutGarp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>GVRP</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutSwitche" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>STP</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutVlan" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>DHCP</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutStp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>ACL</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutPPP" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>NAT</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutGarp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>路由</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 collapsible collapsed" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>HCIP（华为数通中级认证）</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-c4656e6d><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-c4656e6d><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutIp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>认识网络设备</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutRoute" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>IP路由基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutSwitche" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>OSPF基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutVlan" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>OSPF路由计算</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutStp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>OSPF特殊区域以其他特性</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutPPP" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>IS-IS原理与配置</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutGarp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>BGP基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutSwitche" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>BGP路径属性与路由反射器</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutVlan" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>BGP路由优选</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutStp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>BGP EVPN基础</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutPPP" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>路由策略与路由控制</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutGarp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>流量过滤与转发路径控制</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-af16598e><section class="VPSidebarItem level-0 collapsible collapsed" data-v-af16598e data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>深度学习（python）</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-c4656e6d><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-c4656e6d><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/scattered/deeplearn/Overview" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>机器学习和深度学习综述</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutRoute" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>使用Python和NumPy构建神经网络模型</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutSwitche" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>NumPy介绍</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutVlan" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>一个案例吃透深度学习（上）</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutStp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>一个案例吃透深度学习（中）</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutPPP" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>一个案例吃透深度学习（下）</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/netexam/base/aboutGarp" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>卷积神经网络基础</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-b2cf3e0b data-v-a494bd1d><div class="VPDoc has-sidebar has-aside" data-v-a494bd1d data-v-c4b0d3cf><!--[--><!--]--><div class="container" data-v-c4b0d3cf><div class="aside" data-v-c4b0d3cf><div class="aside-curtain" data-v-c4b0d3cf></div><div class="aside-container" data-v-c4b0d3cf><div class="aside-content" data-v-c4b0d3cf><div class="VPDocAside" data-v-c4b0d3cf data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>导航栏</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-9a431c33><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c4b0d3cf><div class="content-container" data-v-c4b0d3cf><!--[--><!--]--><!----><main class="main" data-v-c4b0d3cf><div style="position:relative;" class="vp-doc _scattered_dataStruct_cpp2" data-v-c4b0d3cf><div><h1 id="frontmatter-title" tabindex="-1">简单再次复习一下 C++ <img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305171013458.png" width="46" height="46" alt="图片描述" style="display:inline;margin-bottom:-6px;"> <a class="header-anchor" href="#frontmatter-title" aria-label="Permalink to &quot;{{$frontmatter.title}} &lt;img src=&quot;https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305171013458.png&quot; width=&quot;46&quot; height=&quot;46&quot; alt=&quot;图片描述&quot; style=&quot;display:inline; margin-bottom: -6px&quot;/&gt;&quot;">​</a></h1><h1 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h1><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>概念：能够实现特定功能的程序模块。</p><p>程序是有函数组成的，一个函数就是程序中的一个模块。函数可以相互调用，可以将相互联系密切的语句都放在一个函数内，也可以将负责的函数分解成多个子函数。</p></div><h3 id="函数概述" tabindex="-1">函数概述 <a class="header-anchor" href="#函数概述" aria-label="Permalink to &quot;函数概述&quot;">​</a></h3><ol><li><p>函数的定义</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">类型标识符 函数名(形式参数列表)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    变量声明;</span></span>
<span class="line"><span style="color:#e1e4e8;">    语句</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>类型标识符：用来标识函数的返回值类型，可以根据函数的返回值判断函数的执行情况，通过返回值也可以获取想要的数据。</li><li>形式参数列表：有各种类型变量组成的列表，各参数之间用逗号间隔，在进行函数调用时，主调函数对变量进行赋值。（可以为空）</li></ul></li><li><p>函数的声明：</p><p>调用一个函数前必须先声明函数的返回值类型和参数类型</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">返回值类型  函数名(形式参数列表);</span></span>
<span class="line"><span style="color:#e1e4e8;">int num(int i);</span></span>
<span class="line"><span style="color:#e1e4e8;">// 函数声明被称为函数原型，函数声明时可以省略变量名</span></span>
<span class="line"><span style="color:#e1e4e8;">int num(int );</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 例如</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowAge();</span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowIndex();</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    ShowMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">    ShowAge();</span></span>
<span class="line"><span style="color:#e1e4e8;">    ShowIndex();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowMessage()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowAge()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iAge = 23;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;age is&quot; &lt;&lt; iAge &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowIndex()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iIndex = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;Index is: &quot; &lt;&lt; iIndex &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div></li><li><p>函数返回值</p><p>函数返回值：函数被调用之后，执行函数体中的程序但所取得的并返回给主调函数的值，函数的返回值通过return语句返回给主调函数。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 形式</span></span>
<span class="line"><span style="color:#e1e4e8;">return (表达式);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>返回值说明如下：</p><p>（1）函数返回值的类型和函数定义中函数的类型标识符英保持一致。如果不一致，以函数类型为准，自动进行类型转化</p><p>（2）如函数值为整型，在函数定义是可以省区类型标识符。</p><p>（3）在函数中允许有多个return语句，但每次调用中只能有一个return语句被执行，因此只能返回一个函数值。</p><p>（4）不返回函数值的函数，可以明确定义为“空类型”，类型标识符为void</p><p>（5）类型标识符为void的函数不能进行复制运算及值传递。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>为了降低程序出错概率，凡不要求返回值的函数都应定义为空类型。</p></div></li><li><p>空函数</p><p>没有参数和返回值，函数的作用域为空的函数就是空函数。</p><p>意义：在程序设计中往往需要根据功能分为若干模块，分别由一些函数来实现。</p></li><li><p>形参与实参</p><p>函数定义是如果参数列表为空，说明函数是无参函数，如果参数列表不为空，就称为带参函数。</p><p>形参与实参的区别如下:</p><p>(1)在定义函数中指定的形参，在末出现函数调用时候，它们并不占用内存中的存储单元。值有在发生函数调用时，函数的形参才被分配内存单元，在调用结束后，形参所占的内存单元也被释放。</p><p>（2）实参应该是确定的值，在调用时将实参的值赋值给形参，如果形参是指针类型，就将地址值传递给形参。</p><p>（3）实参 与形参的类型应相同</p><p>（4）实参与形参之间的单向传递，只能由实参传递给形参，而不能由形参传回给实参。</p></li><li><p>默认参数</p><p>在调用带参函数时，如果经常需要传递同一个值到调用函数，在定义函数时，可以为参数设置一个默认值，这样在调用共函数时可以省略一些参数，此时程序将采用默认值作为函数的实际参数。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">void OutputInfo(const char *pachData = &quot;One world,one dream!&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; pchData &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>位置：默认值的参数出现在参数列表的右方。</p></li><li><p>可变参数</p><p>库函数printf就是一个可变参数函数，它的参数列表会显示省略号&quot;...&quot;。</p><p>省略号参数代表的含义是函数的参数是不固定的，可以传递一个或多个参数。</p><p>声明可变参数的函数和声明普通函数一样，只是参数列表中有一个省略号“...”</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">void OutputInfo(int num,...)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ol><h3 id="函数调用" tabindex="-1">函数调用 <a class="header-anchor" href="#函数调用" aria-label="Permalink to &quot;函数调用&quot;">​</a></h3><p>声明完函数后就需要在源代码中调用该函数。整个函数的调用过程被称为函数调用。</p><p>（1）首先被调用的函数必须是已经存在的函数</p><p>（2）如果使用库如果使用库函数，还需要将库函数对应的头文件引入，这需要使用预编译指令#include。</p><p>（3）如果使用用户自定义函数，一般还应在主调函数中对被调用的函数做声明</p><ol><li><p>传值调用</p><p>主调函数和被调函数之间存在着数据传递关系。换句话说，主调函数将实参数值复制到被调用函数的形参处，这种调用方式称为传值调用。如果传递的实参是结构体对象，值传递方式的效率是低下的，可以通过传递指针或使用变量的引用来替换传值调用</p></li><li><p>嵌套调用</p><p>在自定义函数中调用其他自定义函数，这种调用方式称为嵌套调用</p></li></ol><h3 id="函数重载" tabindex="-1">函数重载 <a class="header-anchor" href="#函数重载" aria-label="Permalink to &quot;函数重载&quot;">​</a></h3><p>定义同名的变量，程序会编译出错；定义同名的函数，也会带来冲突的问题。C++中使用了名称重组技术，通过函数的参数类型来识别函数。所谓重载函数，是指多个函数具有相同的函数名，而参数类型或参数个数不同。函数调用时，编译器以参数的类型及个数来区分调用哪个函数。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int Add(int x, int y)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;int add&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    return x + y;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">double Add(double x, double y)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;double add&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    return x + y;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int ivar = Add(5,6);</span></span>
<span class="line"><span style="color:#e1e4e8;">    float fvar = Add(10.2,25.1);</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="内联函数" tabindex="-1">内联函数 <a class="header-anchor" href="#内联函数" aria-label="Permalink to &quot;内联函数&quot;">​</a></h3><p>通过inline关键字可以把函数定义为内联函数，编译器会在每个调用该函数的地方展开一个函数的副本。</p><p>作用：<!----></p><p>建议：建议在函数实现代码很简短或者调用该函数次数相对较少的情况下将函数定义为内联函数，内联函数通常定义一条返回语句，不能包含循环或者switch语句。</p><p>如果某个内联函数要作为外部全局函数，即它将被多个源代码文件使用，那么就把它定义在头文件里，在每个调用该内联函数的源文件中包含该头文件，这种方法保证对每个内联函数只有一个定义，以防止在程序的生命期中引起无意的不匹配。</p><h3 id="变量的存储类别" tabindex="-1">变量的存储类别 <a class="header-anchor" href="#变量的存储类别" aria-label="Permalink to &quot;变量的存储类别&quot;">​</a></h3><p>存储类别是变量的属性之一，C++语言中定义了4种变量的存储类别，分别是auto变量、static变量、register变量和extern变量。</p><ol><li><p>auto变量</p><p>auto（自动）变量是C++语言程序中默认的存储类型。函数内未加存储类型说明的变量均视为auto变量，也就是说，auto变量可省去关键字auto。</p><div class="tip custom-block"><p class="custom-block-title">特点</p><p>(1)auto变量的作用域仅限于定义该变量的个体内。在函数中定义的auto变量，只在该函数内有效；在复合语句中定义的auto变量，只在该复合语句中有效</p><p>(2)auto变量属于动态存储方式，变量分配的内存在栈中，当函数调用结束后，自动变量的值被释放。同样在复合语句中定义的auto变量，在退出复合语句后也不能再使用，否则将引起错误。</p><p>(3)auto变量的作用域和生存期都局限于定义它的个体内（函数或复合语句内），因此不同的个体中允许使用同名的变量而不会混淆。即使在函数内定义的auto变量也可与该函数内部的复合语句中定义的auto变量同名。</p></div></li><li><p>static变量</p><p>在声明变量前加关键字static，可以将变量声明成static（静态）变量。静态局部变量的值在函数调用结束后不消失，静态全局变量只能在本源文件中使用。</p><div class="tip custom-block"><p class="custom-block-title">static变量属于静态存储方式，它具有以下特点。</p><p>(1)static变量在函数内定义，在程序退出时释放，即在程序整个运行期间都不释放，也就是说它的生存期为整个源程序。</p><p>(2)static变量的作用域与auto变量相同，在函数内定义在函数内使用，尽管该变量还继续存在，但不能使用。只有再次调用定义它的函数时，才可继续使用。</p><p>(3)编译器会为静态局部变量赋予0值。</p></div></li><li><p>register变量</p><p>变量的值通常存放在内存中，当需要对一个变量频繁读写时，反复访问内存储器将花费大量的存取时间。为提高效率，C++语言允许将变量声明为register（寄存器）变量，这种变量将局部变量的值存放在CPU中的寄存器中，使用时不需要访问内存，而直接从寄存器中读写。</p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>(1)register变量属于动态存储方式，凡需要采用静态存储方式的量不能定义为register变量。</p><p>(2)编译程序会自动决定哪个变量使用寄存器存储。Register变量起到程序优化的作用。</p></div></li><li><p>extern变量</p><p>在一个源文件中定义的变量和函数只能被本文件中的函数调用。一个C++程序通常有许多源文件。在使用其他源文件的全局变量时，只需要在本源文件中使用extern关键字声明这个变量即可，</p></li></ol><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p><img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/software/install/teamcity/202305220944454.png" alt=""></p><h3 id="一维数组" tabindex="-1">一维数组 <a class="header-anchor" href="#一维数组" aria-label="Permalink to &quot;一维数组&quot;">​</a></h3><ol><li><p>一维数组的声明</p><p>在程序设计中，将同一数据类型的数据按一定形式有序地组织起来，这些有序数据的集合称为数组。一个数组有一个统一的数组名，可以通过数组名和下标来唯一确定数组中的元素。</p><p>格式：<code>数据类型 数组名[常量表达式]</code></p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>(1)数组名的命名规则和变量名相同。</p><p>(2)数组名后面的括号是方括号，方括号内是常量表达式。</p><p>(3)常量表达式表示元素的个数，即数组的长度。</p><p>(4)定义数组的常量表达式不能是变量，因为数组的大小不能动态地定义。</p></div></li><li><p>一维数组元素的引用</p><p>引用一维数组元素的一般形式为“数组名[下标]”。</p><p>格式：<code>int a[10];</code></p><div class="danger custom-block"><p class="custom-block-title">注意</p><p>(1)数组元素的下标起始值是0，而不是1。</p><p>(2)a[10]是不存在的数组元素，引用a[10]非法。</p></div></li><li><p>一维数组的初始化</p><p>数组元素初始化的方式有两种：一种是对单个元素逐一赋值，另一种是使用聚合方式赋值。</p><p>**单一数组元素赋值：**a[0]=0就是对单一数组元素赋值，</p><p>**聚合方式赋值：**数组不仅可以逐一对数组元素赋值，还可以通过大括号进行多个元素的赋值</p></li></ol><h3 id="二维数组" tabindex="-1">二维数组 <a class="header-anchor" href="#二维数组" aria-label="Permalink to &quot;二维数组&quot;">​</a></h3><ol><li><p>二维数组的声明</p><p>形式：<code>数据类型 数组名[常量表达式1][常量表达式2]</code></p><p>一维数组描述的是一个线性序列，二维数组描述的是一个矩阵。常量表达式1代表行数，常量表达式2代表列数。</p><div class="tip custom-block"><p class="custom-block-title">声明</p><p>(1)数组名的命名规则和变量名相同。</p><p>(2)二维数组有两个下标，所以有两个中括号。</p><p>(3)下标运算符中的整数表达式代表数组每一维的长度，必须是正整数，其乘积决定了整个数组的长度。</p><p>(4)定义数组的常量表达式不能是变量，因为数组的大小不能动态地定义。</p></div></li><li><p>二维数组元素的引用</p><p>形式：<code>数组名[下标][下标]</code></p></li><li><p>二维数组的初始化</p><p>二维数组元素初始化的方式和一维数组相同，也分为单个元素逐一赋值和使用聚合方式赋值。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">myArray[0][1] = 10; // 单个元素初始化</span></span>
<span class="line"><span style="color:#e1e4e8;">int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 使用聚合方式赋值</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 使用聚合方式赋值，还可以按行进行赋值，</span></span>
<span class="line"><span style="color:#e1e4e8;">int a[3][4] = {{1,2,3,5},{4,5,6,7},{8,9,10,11}};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol><h3 id="字符数组" tabindex="-1">字符数组 <a class="header-anchor" href="#字符数组" aria-label="Permalink to &quot;字符数组&quot;">​</a></h3><p>用来存放字符数据的数组是字符数组。字符数组中，一个元素存放一个字符。字符数组具有数组的共同属性。</p><ol><li><p>声明一个字符数组: <code>char pWord[11];</code></p></li><li><p>字符数组赋值</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 数组元素逐一赋值</span></span>
<span class="line"><span style="color:#e1e4e8;">pWord[0]=&#39;H&#39;; pWord[1]=&#39;E&#39;; pWord[2]=&#39;L&#39;; pWord[3]=&#39;L&#39;;pWord[4]=&#39;O&#39;; pWord[5]=&#39;&#39;; pWord[6]=W&#39;; pWord[7]=&#39;O&#39;;pWord[8]=&#39;R&#39;; pWord[9]=&#39;L&#39;; pWord[10]=&#39;D&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 聚合方式赋值</span></span>
<span class="line"><span style="color:#e1e4e8;">char pWord[] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39; &#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p>字符数组声明</p><p>聚合方式赋值只能在数组声明时使用，</p><p>字符数组不能给字符数组赋值。</p></li><li><p>字符串和字符串结束符</p><p>字符数组常用于存储字符串，此时要连同字符串结束符&#39;\0&#39;一起保存。</p></li><li><p>字符串处理函数</p><p>（1）strcat函数</p><p>作用：strcat函数把字符数组2中的字符串连接到字符数组1中字符串的后面，并删去原字符数组1中的字符串结束符&#39;\0&#39;。</p><p>格式：<code>strcat(字符数组名1， 字符数组名2)</code></p><p>说明: <!----></p><p>(2) strcpy函数</p><p>作用：strcpy函数把字符数组2中的字符串复制到字符数组1中，字符串结束符&#39;\0&#39;也一同复制。</p><p>格式：<code>strcpy(字符数组名1，字符数组名2)</code></p><div class="danger custom-block"><p class="custom-block-title">说明</p><p>(1)要求字符数组1应有足够的长度，以便全部装入所复制的字符串。</p><p>(2)“字符数组1”必须写成数组名形式，而“字符数组2”可以是字符数组名，也可以是一个字符串常量，这时相当于把一个字符串赋予一个字符数组。</p></div><p>(3) strcmp函数</p><p>作用：strcmp函数按照ASCII码顺序比较两个数组中的字符串，并返回比较结果。</p><ul><li>[x] 字符串1=字符串2，返回值为0。</li><li>[x] 字符串1&gt;字符串2，返回值为一正数。</li><li>[x] 字符串1&lt;字符串2，返回值为一负数。</li></ul><p>格式：<code>strcmp(字符数组名1，字符数组名2)</code></p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>进行比较时若出现不同的字符，则以第一个不同字符比较结果作为整个比较的结果。</p><p>字符串比较不能使用关系运算符，也不能使用赋值运算符进行赋值得到数据。</p></div><p>(4)strlen函数</p><p>作用：strlen函数测字符串的实际长度（不含字符串结束符&#39;\0&#39;），函数返回值为字符串的实际长度。</p><p>格式：<code>strlen(字符数组名)</code></p></li></ol><h2 id="指针" tabindex="-1">指针 <a class="header-anchor" href="#指针" aria-label="Permalink to &quot;指针&quot;">​</a></h2><p>指针是一种数据类型，通常所说的指针就是指针变量，它是一个专门用来存放地址的变量，而变量的指针主要是指变量在内存中的地址。变量的地址在编写代码时无法获取，只有在程序运行时才能得到。</p><h3 id="变量与指针" tabindex="-1">变量与指针 <a class="header-anchor" href="#变量与指针" aria-label="Permalink to &quot;变量与指针&quot;">​</a></h3><ol><li><p>指针的声明</p><p>格式：<code>数据类型标识符 *指针变量名</code></p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>定义指针变量时，必须指定一个数据类型。指针变量的数据类型用来指定该指针变量所指向数据的类型。</p></div></li><li><p>指针赋值</p><p>指针可以在声明是进行初始化赋值，也可以后期在赋值。</p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>通过变量名访问一个变量是直接的，而通过指针访问一个变量是间接的。</p></div></li><li><p>关于指针使用说明</p><p>(1)指针变量名是p，而不是*p，p = &amp;i的意思是去变量i的地址赋给指针变量p。</p><p>(2)指针变量不能直接赋值。</p><p>(3)不能将*p当变量使用</p><div class="danger custom-block"><p class="custom-block-title">误区警示</p><p>什么是野指针？没有初始化的指针变量俗称“野指针”。这种没有初始化的指针变量并非不能使用，但是有一定错误危害（不合法内存空间），为了防止这种危害，良好的编程习惯是在定义指针变量时将其初始化为NULL。由于NULL处禁止写入，所以一旦有错误，就可以将错误造成的危害降到最小。</p></div></li></ol><h3 id="指针运算符和取地址运算符" tabindex="-1">指针运算符和取地址运算符 <a class="header-anchor" href="#指针运算符和取地址运算符" aria-label="Permalink to &quot;指针运算符和取地址运算符&quot;">​</a></h3><ol><li><p>指针运算符和取地址运算符简介</p><p>*和&amp;是两个运算符，*是指针运算符，&amp;是取地址运算符。</p></li><li><p>指针运算符和取地址运算符的说明</p><p>声明并初始化变量时，同时会使用用到*和&amp;两个运算符。<code>int *p = &amp;a;</code></p></li><li><p>&amp;*p和*&amp;a的区别</p><p>&amp;和*的运算符优先级别相同，按自右而左的方向结合。因此，&amp;*p是先进行*运算，*p相当于变量a；再进行&amp;运算，&amp;*p就相当于取变量a的地址。*&amp;a是先计算&amp;运算符，&amp;a就是取变量a的地址，然后计算*运算，*&amp;a相当于取变量a所在地址的值，实际就是变量a。</p></li></ol><h3 id="指针运算" tabindex="-1">指针运算 <a class="header-anchor" href="#指针运算" aria-label="Permalink to &quot;指针运算&quot;">​</a></h3><p>指针变量存储的是地址，对指针做运算就等于对地址做运算</p><h3 id="指向空的指针与空类型指针" tabindex="-1">指向空的指针与空类型指针 <a class="header-anchor" href="#指向空的指针与空类型指针" aria-label="Permalink to &quot;指向空的指针与空类型指针&quot;">​</a></h3><p>指针可以指向任何数据类型的数据，包括空类型（void）：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">void *p; // 定义一个指向空类型的指针变量</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>空类型指针可以接受任何类型的数据，可以将其强制转化为所对应的数据类型。</p><h3 id="指向向量的指针与指针常量" tabindex="-1">指向向量的指针与指针常量 <a class="header-anchor" href="#指向向量的指针与指针常量" aria-label="Permalink to &quot;指向向量的指针与指针常量&quot;">​</a></h3><p>同其他数据类型一样，指针也有常量，使用const关键字。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int i = 9;</span></span>
<span class="line"><span style="color:#e1e4e8;">int *const p = &amp;i;</span></span>
<span class="line"><span style="color:#e1e4e8;">*p = 3;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>将关键字const放在标识符前，表示这个数据本身是常量，而数据类型是int *，即整型指针。与其他常量一样，指针常量必须初始化。虽然无法改变它的内存指向，但是可以改变它指向内存的内容。</p><p>若将关键字const放在指针类型的前方</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int i = 9;</span></span>
<span class="line"><span style="color:#e1e4e8;">int const *p = &amp;i;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这是指向常量的指针，虽然它指向的数据可以通过赋值语句进行修改，但是通过该指针修改内存内容的操作是不被允许的。</p><p>当const以如下形式使用时：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int i = 9;</span></span>
<span class="line"><span style="color:#e1e4e8;">int const *const p = &amp;i;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该指针是一个指针常量，即不能改变它的内存指向，页不能通过它修改指向内存的内容。</p><h2 id="指针与数组" tabindex="-1">指针与数组 <a class="header-anchor" href="#指针与数组" aria-label="Permalink to &quot;指针与数组&quot;">​</a></h2><h3 id="数组的存储" tabindex="-1">数组的存储 <a class="header-anchor" href="#数组的存储" aria-label="Permalink to &quot;数组的存储&quot;">​</a></h3><p>数组作为同名、同类型元素的有序集合，被顺序存放在一块连续的内存中，而且每个元素存储空间的大小相同。数组第一元素的存储地址就是整个数组的存储首地址，该地址放在数组名中。对于一维数组而言，其结构是线性的，所以数组元素按下标值由小到大的顺序依次存放在一块连续的内存中。对于二维数组而言，用矩阵方式存储元素，在内存中仍然是线性结构。</p><h3 id="指针与一维数组" tabindex="-1">指针与一维数组 <a class="header-anchor" href="#指针与一维数组" aria-label="Permalink to &quot;指针与一维数组&quot;">​</a></h3><p>系统需要提供一定量连续的内存来存储数组中的各元素，内存都有地址，指针变量就是存放地址的变量，如果把数组的地址赋给指针变量，就可以通过指针变量引用数组。引用数组元素有两种方法：下标法和指针法。</p><p>通过指针引用数组，要先声明一个数组，在声明一个指针。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int a[10];</span></span>
<span class="line"><span style="color:#e1e4e8;">int *p;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后通过&amp;运算符获取数组中元素的地址，在将地址赋给指针变量。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">p = &amp;a[0];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>把a[0]元素的地址赋给指针变量p，即p指向a数组的第0号元素。</p><p>如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素。p+i和a+i是a[i]的地址。a代表首元素的地址，a+i也是地址，对应数组元素a[i]。(p+i)或*(a+i)是p+i或a+i指向的数组元素，即a[i]。</p><h3 id="指针与二维数组" tabindex="-1">指针与二维数组 <a class="header-anchor" href="#指针与二维数组" aria-label="Permalink to &quot;指针与二维数组&quot;">​</a></h3><p>可以将一维数组的地址赋给指针变量，同样也可以将二维数组的地址赋给指针变量，因为一维数组和二维数组的内存地址都是连续的，可以将二维数组看成一维数组。</p><h3 id="指针与字符数组" tabindex="-1">指针与字符数组 <a class="header-anchor" href="#指针与字符数组" aria-label="Permalink to &quot;指针与字符数组&quot;">​</a></h3><p>字符数组是一个一维数组，使用指针同样可以引用字符数组。引用字符数组的指针为字符指针，字符指针是指向字符型内存空间的指针变量，</p><p>字符数组就是一个字符串，通过字符指针可以指向一个字符串。</p><h2 id="指针数组" tabindex="-1">指针数组 <a class="header-anchor" href="#指针数组" aria-label="Permalink to &quot;指针数组&quot;">​</a></h2><p>数组中的元素均为指针变量的数组称为指针数组。</p><p>格式：<code>类型名 *数组名[数组长度];</code></p><h2 id="安全使用指针" tabindex="-1">安全使用指针 <a class="header-anchor" href="#安全使用指针" aria-label="Permalink to &quot;安全使用指针&quot;">​</a></h2><h3 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to &quot;内存分配&quot;">​</a></h3><ol><li><p>堆与栈</p><p>在程序中定义一个变量，它的值会被放入内存中。如果没有申请动态分配的方式，它的值将被放到栈中。在栈中变量占用的内存大小是无法改变的，它们的占用与释放也与变量定义的位置和储存方式有关。与栈相对应，堆是一种动态分配的内存。当申请使用动态分配方式储存某个变量，那么这个变量会被放入堆中。根据需要，这个变量的内存大小可以改变，内存的申请和释放的时机则由编程者操作。</p></li><li><p>关键字new与delete</p><p>创建变量之前，编译器没有获取变量名，只具有指向该变量的指针。那么，申请变量的堆内存即是申请自身指向堆。new是c++语言申请动态内存的关键字。</p><p>形式: <code>p1 = new type;</code></p><p>其中，p1表示指针，new是关键字，type是类型名。new返回新分配的内存单元的地址。</p><p>这样，pl指针就申请了动态方式，使用它在堆内申请的内存储存int类型的值。</p></li><li><p>变量p接受了newGet返回的指针的堆内存地址，所以内存的内容并没有被销毁，而栈内存则由系统控制。程序最后使用delete语句释放堆内存。</p></li></ol><h3 id="内存安全" tabindex="-1">内存安全 <a class="header-anchor" href="#内存安全" aria-label="Permalink to &quot;内存安全&quot;">​</a></h3><p>指针是一种灵活高效的内存访问机制，可以通过变量在内存中的地址对变量直接操作。指针不能访问寄存器变量，因为它并没有保存在内存中，而是保存在寄存器中（从寄存器中读取数据要比从内存中读取数据速度快，所以有些要求频繁使用的数据可以放在寄存器中）。指针只能访问内存，不能访问寄存器，所以指针访问不到寄存器变量。</p><h2 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h2><h3 id="引用概述" tabindex="-1">引用概述 <a class="header-anchor" href="#引用概述" aria-label="Permalink to &quot;引用概述&quot;">​</a></h3><p>在C++11标准中提出了左值引用的概念，如果不加特殊声明，一般都是指左值引用。引用实际上是一种隐式指针，它为对象建立一个别名，通过操作符&amp;来实现。&amp;是取地址操作符，通过它可以获得地址。</p><p>格式：<code>数据类型 &amp; 表达式;</code></p><p>例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int a = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">int &amp; ia = a;</span></span>
<span class="line"><span style="color:#e1e4e8;">ia = 2;</span></span>
<span class="line"><span style="color:#e1e4e8;">//定义一个引用变量ia，它是变量a的别名，对ia的操作与对a的操作完全一样。ia=2把2赋给a，&amp;ia返回a的地址。执行ia=2和执行a=2等价。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>说明：</p><p>(1)一个C++引用被初始化后，无法使用它再去引用另一个对象，它不能被重新约束。</p><p>(2)引用变量只是其他对象的别名，对它的操作与对原来对象的操作具有相同作用。</p><p>(3)指针变量与引用有两点主要区别：一是指针是一种数据类型，而引用不是一种数据类型，指针可以转换为它指向变量的数据类型，以便赋值运算符两边的类型相匹配；而在使用引用时，系统要求引用和变量的数据类型必须相同，不能进行数据类型转换。二是指针变量和引用变量都用来指向其他变量，但指针变量使用的语法更复杂；在定义了引用变量后，其使用方法与普通变量相同。</p><p>(4)引用须初始化，否则会报错。</p><p>右值引用<code>类型 &amp;&amp; i = 被引用的对象;</code></p><p>右值引用可以理解为右值的引用，当右值引用初始化后，临时变量消失</p><h3 id="使用引用传递参数" tabindex="-1">使用引用传递参数 <a class="header-anchor" href="#使用引用传递参数" aria-label="Permalink to &quot;使用引用传递参数&quot;">​</a></h3><p>在C++语言中，函数参数的传递方式主要有两种，分别为值传递和引用传递。所谓值传递，是指在函数调用时，将实际参数的值赋值调用函数，这样如果在调用函数中修改了参数的值，其改变不会影响实际参数的值。而引用传递则恰恰相反，如果函数按引用方式传递，在调用函数中修改了参数的值，其改变会影响实际参数。</p><h3 id="指针传递参数" tabindex="-1">指针传递参数 <a class="header-anchor" href="#指针传递参数" aria-label="Permalink to &quot;指针传递参数&quot;">​</a></h3><p>指针变量可以作为函数参数。使用指针变量传递参数和使用引用传递方式的执行效果相同，</p><p>通过指针传递参数和使用引用方式传递参数一样，都可以减少值传递带来的开销。实际上，使用指针和引用类型作为函数参数各有优缺点，视具体环境而定。对于引用类型，引用必须被初始化为一个对象，并且不能使它再指向其他对象，因为对应用赋值实际上是对目标对象赋值。这是引用类型的缺点，也是引用类型的优点，因为在函数中不用验证引用参数的合法性，</p><h3 id="数组做函数参数" tabindex="-1">数组做函数参数 <a class="header-anchor" href="#数组做函数参数" aria-label="Permalink to &quot;数组做函数参数&quot;">​</a></h3><p>在函数调用过程中，有时需要传递多个参数，如果传递的参数都是同一类型，则可以通过数组的方式来传递参数，作为参数的数组可以是一维数组，也可以是多维数组。使用数组做函数参数最典型的就是main函数。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">main(int argc,char *argv[])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="构造数据类型" tabindex="-1">构造数据类型 <a class="header-anchor" href="#构造数据类型" aria-label="Permalink to &quot;构造数据类型&quot;">​</a></h2><p><img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/software/install/teamcity/202305222042020.png" alt=""></p><h3 id="结构体定义" tabindex="-1">结构体定义 <a class="header-anchor" href="#结构体定义" aria-label="Permalink to &quot;结构体定义&quot;">​</a></h3><p>整型、长整型、字符型、浮点型等数据类型只能记录单一的数据，称作基本数据类型。如果描述一个人，就需要定义多个变量来记录这些信息，例如，身高、体重、姓名、年龄各需要一个变量。如果有一个类型可以将这些变量组合在一起，则会大大减少程序代码的离散性，使之更加符合逻辑，结构体则是实现这一功能的类型。</p><p>格式：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct 结构体类型名</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    成员类型 成员名;</span></span>
<span class="line"><span style="color:#e1e4e8;">    ...;</span></span>
<span class="line"><span style="color:#e1e4e8;">    成员类型 成员名;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>struct是定义结构体的关键字。结构体类型名是一种标识符，该标识符代表一个新的变量。结构体使用大括号将成员括起来，每个成员都有自己的类型，成员类型可以是常规的基础类型、自定义类型或类类型。</p><div class="language-C++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">C++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 定义一个简单员工信息的结构体</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">说明</p><p>结构体是由多个不同类型的数据组成的数据集合，而数组是由相同类型元素组成的数据集合。</p></div><h3 id="结构体变量" tabindex="-1">结构体变量 <a class="header-anchor" href="#结构体变量" aria-label="Permalink to &quot;结构体变量&quot;">​</a></h3><p>结构体是一个构造类型，前面只是定义了结构体，形成一个新的数据类型，还需要使用该数据类型定义变量，结构体变量有来个那种声明形式。</p><p>一种是在定义结构体后，使用结构体类型名声明，</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonIfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">PersonIfo pInfo;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>一种是定义结构体是直接声明，</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">} pInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 直接声明结构体变量时，可以声明多个变量。</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}pInfo,pInfo1;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="结构体成员及初始化" tabindex="-1">结构体成员及初始化 <a class="header-anchor" href="#结构体成员及初始化" aria-label="Permalink to &quot;结构体成员及初始化&quot;">​</a></h3><p>引用结构体成员有两种方式：</p><!----><p>(1)使用成员运算符“.”引用，</p><p>格式: <code>结构体变量名.成员名</code></p><p>例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}pInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;">pInfo.index;</span></span>
<span class="line"><span style="color:#e1e4e8;">pInfo.name;</span></span>
<span class="line"><span style="color:#e1e4e8;">pInfo.age;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>引用结构体成员后，分别对结构体成员赋值，对于每个结构体成员就和使用普通变量一样。</p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>并不是所有的结构体成员都可以赋值，如果某个结构体变量的某个成员使用const限定，就不能对它赋值。</p></div><p>(2)在定义结构体时，可以同时声明结构体指针变量，</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}*pPersonInfo;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><!----><p>如果要引用指针结构体变量的成员，需要使用指向运算符“-&gt;”</p><p>形式：<code>结构体指针变量 -&gt; 成员名</code></p><p>例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">pPersonInfo -&gt; index;</span></span>
<span class="line"><span style="color:#e1e4e8;">pPersonInfo -&gt; name;</span></span>
<span class="line"><span style="color:#e1e4e8;">pPersonInfo -&gt; age;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>结构体指针变量只有初始化才能使用。</p></div><h3 id="结构体的嵌套" tabindex="-1">结构体的嵌套 <a class="header-anchor" href="#结构体的嵌套" aria-label="Permalink to &quot;结构体的嵌套&quot;">​</a></h3><p>定义结构体后就形成一个新的数据类型，C++语言在定义结构体时可以声明其他已定义好的结构体变量，也可以在定义结构体时定义子结构体。</p><p>(1)在结构体中定义子结构体，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">    struct workPlace</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        char Address[150];</span></span>
<span class="line"><span style="color:#e1e4e8;">        char PostCode[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">        char GateCode[50];</span></span>
<span class="line"><span style="color:#e1e4e8;">        char Street[100];</span></span>
<span class="line"><span style="color:#e1e4e8;">        char Area[50];</span></span>
<span class="line"><span style="color:#e1e4e8;">    };</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>(2)在定义时声明其他已定义好的结构体变量，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct WorkPlace</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">     char Address[150];</span></span>
<span class="line"><span style="color:#e1e4e8;">     char PostCode[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">     char GateCode[50];</span></span>
<span class="line"><span style="color:#e1e4e8;">     char Street[100];</span></span>
<span class="line"><span style="color:#e1e4e8;">     char Area[50];</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">    WorkPlace myWorkPlace;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="结构体大小" tabindex="-1">结构体大小 <a class="header-anchor" href="#结构体大小" aria-label="Permalink to &quot;结构体大小&quot;">​</a></h3><p>结构体是一种构造的数据类型，数据类型都与占用内存多少有关。在没有字符对齐要求或结构体成员对齐单位为1时，结构体变量的大小是定义结构体时各成员大小之和。</p><h3 id="重命名数据类型" tabindex="-1">重命名数据类型 <a class="header-anchor" href="#重命名数据类型" aria-label="Permalink to &quot;重命名数据类型&quot;">​</a></h3><p>C++允许使用关键字typedef给一个数据类型定义一个别名，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">typedef int flag; // 给int数据类型取一个别名</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样，程序中flag就可以作为int的数据类型来使用<code>flag a;</code></p><p>a实质上是int类型的数据，此时int类型的别名就是flag。</p><p>类或者结构在声明时，如果使用typedef，</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">typedef class asdfghj{</span></span>
<span class="line"><span style="color:#e1e4e8;">    成员列表</span></span>
<span class="line"><span style="color:#e1e4e8;">}myClass,ClassA;</span></span>
<span class="line"><span style="color:#e1e4e8;">// 这样就令声明的类拥有myClass和ClassA两个别名</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>typedef主要用途如下</p><p>(1)代替复杂的基本类型名称，例如函数指针int(*)(int i)</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">typedef int (*)(int i) pFun;  // 用pFun代替函数指针int （*)(int i)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>(2)使用其他人开发的类型时，使它的类型名符合自己的代码习惯（规范）。typedef关键字具有作用域，范围是别名声明所在的区域（包含名称空间）。</p><h3 id="结构体与函数" tabindex="-1">结构体与函数 <a class="header-anchor" href="#结构体与函数" aria-label="Permalink to &quot;结构体与函数&quot;">​</a></h3><p>结构体数据类型在C++语言中是可以作为函数参数传递的，可以直接使用结构体变量做函数的参数，也可以使用结构体指针变量做函数的参数。</p><h3 id="结构体变量做函数参数" tabindex="-1">结构体变量做函数参数 <a class="header-anchor" href="#结构体变量做函数参数" aria-label="Permalink to &quot;结构体变量做函数参数&quot;">​</a></h3><p>可以把结构体当作普通变量一样作为函数参数，这样可以减少函数参数的个数。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonIfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    float weight;</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowStructMessage(struct PersonInfo MyInfo)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;小喵的名字：&quot; &lt;&lt; MyInfo.name &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;小喵的体重：&quot; &lt;&lt; MyInfo.weight &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;小喵的年龄：&quot; &lt;&lt; MyInfo.age &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    PersonInfo pInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(pInfo.name,&quot;草莓&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    pInfo.weight = 2.5f;</span></span>
<span class="line"><span style="color:#e1e4e8;">    pInfo.age = 2;</span></span>
<span class="line"><span style="color:#e1e4e8;">    showStructMessage(pInfo);</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="结构体指针做函数参数" tabindex="-1">结构体指针做函数参数 <a class="header-anchor" href="#结构体指针做函数参数" aria-label="Permalink to &quot;结构体指针做函数参数&quot;">​</a></h3><p>使用结构体指针做函数参数时传递的只是地址，减少了时间和空间上的开销，能够提高程序的运行效率。这种方式在实际应用中效果比较好。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">//使用结构体指针变量做函数参数</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char work[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">void ShowStructMessage(struct PersonInfo *pInfo)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; pInfo-&gt;name &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;职员号：&quot; &lt;&lt; pInfo-&gt;index &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;职位：&quot; &lt;&lt; pInfo-&gt;work &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    PersonInfo pInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(pInfo.name， &quot;张伟&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    pInfo.index = 14;</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(pInfo.work, &quot;开发部&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;----信息如下-----&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    ShowStructMessage(&amp;pInfo);</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="结构体数组声明与引用" tabindex="-1">结构体数组声明与引用 <a class="header-anchor" href="#结构体数组声明与引用" aria-label="Permalink to &quot;结构体数组声明与引用&quot;">​</a></h3><p>结构体数组可以在定义结构体时直接声明，也可以使用结构体变量声明，还可以直接声明结构体数组而无须定义结构体名。</p><p>（1）在定义结构体时直接声明</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonIfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}Person[5];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>(2)使用结构体变量声明，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}pInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;">PersonInfo Person[5];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>(3)直接声明结构体数组，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int index;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char name[30];</span></span>
<span class="line"><span style="color:#e1e4e8;">    short age;</span></span>
<span class="line"><span style="color:#e1e4e8;">}Person[5] = {{},{},{},{},{}}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="指针访问结构体数组" tabindex="-1">指针访问结构体数组 <a class="header-anchor" href="#指针访问结构体数组" aria-label="Permalink to &quot;指针访问结构体数组&quot;">​</a></h3><p>指针可以指向一个结构体数组，这时结构体指针的值是整个结构体数组的首地址。结构体指针也可指向结构体数组的一个元素，这时结构体指针的值是该结构体数组元素的首地址。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">//显示销售前5名的产品</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">struct PersonInfo</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    char cName[20];</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iNumber;</span></span>
<span class="line"><span style="color:#e1e4e8;">}Person[5]={{},{},{},{},{}};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    struct PersonInfo *pPersonInfo;</span></span>
<span class="line"><span style="color:#e1e4e8;">    pPersonInfo = Person;</span></span>
<span class="line"><span style="color:#e1e4e8;">    for(int i = 0; i &lt; 5; i++, pPersionInfo++)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;产品名：&quot; &lt;&lt; pPersonInfo-&gt;cName &lt;&lt; &quot; &quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;销售量：&quot; &lt;&lt; pPersonInfo-&gt;iNumber &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="共用体" tabindex="-1">共用体 <a class="header-anchor" href="#共用体" aria-label="Permalink to &quot;共用体&quot;">​</a></h3><p>共用体数据类型是指将不同的数据项组织为一个整体，它和结构体有些类似，但共用体在内存中占用首地址相同的一段存储单元。因为共用体的关键字为union，即联合，所以共用体也称联合体。</p><h3 id="共用体的定义与声明" tabindex="-1">共用体的定义与声明 <a class="header-anchor" href="#共用体的定义与声明" aria-label="Permalink to &quot;共用体的定义与声明&quot;">​</a></h3><p>格式</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">union 共用体类型名</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    成员类型 共用体成员名1;</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">    成员类型 共用体成员名1;</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">    成员类型 共用体成员名n;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>union是定义共用体数据类型的关键字，共用体类型名是一个标识符，该标识符就是一个新的数据类型，成员类型是常规的数据类型，用来设置共用体成员存储空间。</p><p>声明共用体数据类型变量有以下几种方式。</p><p>(1)先定义共用体，然后声明共用体变量，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">union myUnion</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int i;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char ch;</span></span>
<span class="line"><span style="color:#e1e4e8;">    float f;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">myUnion u; // 声明变量</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>(2)直接在定义时声明共用体变量，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">union myUnion</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int i;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char ch;</span></span>
<span class="line"><span style="color:#e1e4e8;">    float f;</span></span>
<span class="line"><span style="color:#e1e4e8;">}u; // 直接声明变量</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>(3)直接声明共用体变量，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">union </span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int i;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char ch;</span></span>
<span class="line"><span style="color:#e1e4e8;">    float f;</span></span>
<span class="line"><span style="color:#e1e4e8;">}u;</span></span>
<span class="line"><span style="color:#e1e4e8;">//第三种方式省略了共用体类型名，直接声明了变量u。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><!----><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>初学者可能会有疑惑：共用体变量名可以赋值吗？其实只要赋的值是一个相同类型的共用体类型即可。引用共用体变量名也可以得到一个值，这个值就是共用体对象本身的值。</p></div><h3 id="共用体的大小" tabindex="-1">共用体的大小 <a class="header-anchor" href="#共用体的大小" aria-label="Permalink to &quot;共用体的大小&quot;">​</a></h3><p>共用体每个成员分别占有自己的内存单元。共用体变量所占的内存长度等于最长的成员的长度。一个共用体变量不能同时存放多个成员的值，某一时刻只能存放最后赋予它的值。</p><h3 id="共用体的特点" tabindex="-1">共用体的特点 <a class="header-anchor" href="#共用体的特点" aria-label="Permalink to &quot;共用体的特点&quot;">​</a></h3><p>共用体数据类型有以下几个特点。</p><p>(1)使用共用体变量的目的是用同一个内存段存放几种不同类型的数据。注意，在同一时间只能存放其中的一种，而不能同时存放几种。</p><p>(2)能够访问的是共用体变量中最后一次被赋值的成员，在对一个新的成员赋值后，原有的成员将随之改变。</p><p>(3)共用体变量的地址和它的各成员的地址是一致的。</p><p>(4)不能对共用体变量名赋值，不能企图引用变量名来得到一个值，不能在定义共用体变量时对它初始化，不能用共用体变量名作为函数参数。</p><h2 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h2><p>枚举就是一一列举的意思，在C++语言中枚举类型是一些标识符的集合，从形式上看枚举类型就是用大括号将不同标识符名称放在一起。用枚举类型声明的变量，其值只能取自括号内的标识符。</p><h3 id="枚举类型的声明" tabindex="-1">枚举类型的声明 <a class="header-anchor" href="#枚举类型的声明" aria-label="Permalink to &quot;枚举类型的声明&quot;">​</a></h3><p>(1)枚举类型的一般声明形式：<code>enum 枚举类型名 {标识符列表};</code></p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">enum weekday {Sunday,Monday,Tuesday,wednesday,Thursday,Friday,Saturday};</span></span>
<span class="line"><span style="color:#e1e4e8;">//enum是定义枚举类型的关键字，weekday是新定义的类型名，大括号内是枚举类型变量可取的值。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>(2)带赋值的枚举类型声明形式如下：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">enum 枚举类型名</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    标识符[=整型常数],</span></span>
<span class="line"><span style="color:#e1e4e8;">    标识符[=整型常量],</span></span>
<span class="line"><span style="color:#e1e4e8;">    ...;</span></span>
<span class="line"><span style="color:#e1e4e8;">    标识符[=整型常数]</span></span>
<span class="line"><span style="color:#e1e4e8;">}枚举变量；</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用枚举类型的说明如下。</p><p>(1)编译器默认将标识符自动赋值整型常数。例如：</p><p>(2)可以自行修改整型常数的值。例如：</p><p>(3)如果只给前几个标识符赋整型常数，编译器会给后面标识符自动累加赋值。例如：</p><h3 id="枚举类型变量" tabindex="-1">枚举类型变量 <a class="header-anchor" href="#枚举类型变量" aria-label="Permalink to &quot;枚举类型变量&quot;">​</a></h3><p>在声明枚举类型后，可以用它定义变量。例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">enum weekday {Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Satruday};</span></span>
<span class="line"><span style="color:#e1e4e8;">[enum] weekday myworkday;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>myworkday是weekday的变量。在C++中，枚举类型名包括关键字enum，因此允许不写enum关键字。</p><p>关于使用枚举变量的说明：</p><p>（1）枚举变量的值只能是从Sunday到Saturday之一，即只能是大括号内的值。</p><p>（2）一个整数不能直接赋给一个枚举变量。整型虽然不能直接为枚举变量赋值，但是可以通过强制类型转换，将整数转换为合适的枚举型数值。</p><p>（3）直接定义枚举变量。</p><h3 id="枚举类型的运算" tabindex="-1">枚举类型的运算 <a class="header-anchor" href="#枚举类型的运算" aria-label="Permalink to &quot;枚举类型的运算&quot;">​</a></h3><p>枚举值相当于整型变量，可以进行运算。</p><p>(1)利用枚举值做判断比较。枚举值可以和整型变量比较，枚举值之间也可以进行比较。</p><p>(2)利用枚举值进行减法运算。</p><div class="danger custom-block"><p class="custom-block-title">误区警示</p><p>枚举类型到底什么时候使用？在实际问题中，有些变量被限定在一个有限的范围内。例如，一个星期有7天、一年有12个月等，把这些量声明为整型、字符型或其他类型显然是不妥的。为此，C++语言提供了枚举类型。枚举类型是一种基本数据类型，不能再分解为其他类型。</p></div><h3 id="自定义数据类型" tabindex="-1">自定义数据类型 <a class="header-anchor" href="#自定义数据类型" aria-label="Permalink to &quot;自定义数据类型&quot;">​</a></h3><p>C++语言提供了丰富的数据类型，对于由用户自己定义的构造型数据类型，还允许用户自己定义类型说明符，即由用户为定义的数据类型名另外再取一个别名，以便简化对类型名的引用或增加程序的可读性。这个功能由类型定义符typedef完成。typedef的使用形式：<code>typedef &lt;原类型名&gt; &lt;新类型名&gt;</code></p><p>原类型名是任意已定义的数据类型，包括系统的各种基本数据类型名以及用户自定义的构造类型名。新类型名是用户自己命名的标识符，在以后变量的声明中可以直接使用该名称。</p><h2 id="使用宏定义替换复杂的数据" tabindex="-1">使用宏定义替换复杂的数据 <a class="header-anchor" href="#使用宏定义替换复杂的数据" aria-label="Permalink to &quot;使用宏定义替换复杂的数据&quot;">​</a></h2><p>经常遇到用#define命令定义符号常量的情况，其实使用#define命令就是要定义一个可替换的宏，宏定义是预处理命令的一种。它提供了一种可以替换源代码中字符串的机制。根据宏定义中是否有参数，可以将其分为不带参数的宏定义和带参数的宏定义两种。</p><p>1.不带参数的宏定义</p><p>宏定义指令#define用来定义一个标识符和一个字符串，以这个标识符来代表这个字符串。在程序中每次遇到该标识符时，就用定义的字符串替换它。它的作用相当于给指定的字符串起一个别名。形式：<code>#define 宏名 字符串</code></p><p>使用#define进行宏定义的好处是：当需要改变一个常量时，只需改变#define命令行，整个程序的常量都会改变，大大提高了程序的灵活性。</p><p>关于不带参数的宏定义，要强调以下几点。</p><div class="danger custom-block"><p class="custom-block-title">强调</p><p>(1)如果在字符串中含有宏名，则不进行替换。</p><p>(2)如果字符串长于一行，可以在该行末尾用一反斜杠“\”续行。</p><p>(3)#define命令出现在程序中函数的外面，宏名的有效范围为定义命令之后到此源文件结束。</p><p>(4)可以用#undef命令终止宏定义的作用域。</p><p>(5)宏定义用于预处理命令，它不同于定义的变量，只进行字符替换，不分配内存空间。</p></div><p>2.带参数的宏定义.<code>#define 宏名(参数表)字符串</code></p><p>用宏替换的一个好处是，因为不存在函数调用，所以可提高代码的速度。但提高速度也有代价，因为重复编码会增加代码的长度。</p><div class="danger custom-block"><p class="custom-block-title">强调</p><p>(1)宏定义时参数要加括号。如不加括号，有时结果是正确的，有时结果便是错误的。</p><p>(2)宏扩展必须使用括号来保护表达式中低优先级的操作符，以确保调用时达到想要的效果。</p><p>(3)对带参数的宏的展开，只是将宏名后面括号内的实参字符串代替#define命令行中的形参。</p><p>(4)在宏定义时，宏名与带参数的括号之间不能加空格，否则将空格以后的字符都作为替代字符串的一部分。</p><p>(5)在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义。</p></div><h1 id="核心" tabindex="-1">核心 <a class="header-anchor" href="#核心" aria-label="Permalink to &quot;核心&quot;">​</a></h1><h2 id="面向对象编程" tabindex="-1">面向对象编程 <a class="header-anchor" href="#面向对象编程" aria-label="Permalink to &quot;面向对象编程&quot;">​</a></h2><p>面向对象编程是一种编程范式，它的思想基于现实世界中的对象及其相互关系。在面向对象编程中，对象是指一组属性和方法的集合，对象之间通过消息传递来进行交互，而不是像传统的过程式编程中一样，对数据进行操作。</p><p>面向对象编程的核心思想是将系统划分为一系列相互关联的对象，每个对象都有自己的属性和行为，对象之间通过消息传递来相互协作。面向对象编程强调代码的可重用性、可维护性和可扩展性，通过封装、继承和多态性等特性来实现这些优点。</p><p>封装是指对象将自己的数据和方法隐藏起来，只向外部暴露必要的接口，从而保证对象的独立性和安全性。继承是指一个对象可以从另一个对象中继承其属性和方法，从而减少代码重复，提高代码的可维护性。多态性是指同一行为在不同的对象上具有不同表现形式的能力，使得程序更加灵活和扩展性更高。</p><p>面向对象编程是现代程序设计中的主流思想，它已经被广泛应用于软件开发、游戏开发、Web开发等领域。对于程序员来说，掌握面向对象编程思想是很重要的基础知识。</p><p>面向对象有3大特点，即封装、继承和多态。具体来说：</p><ol><li><p>封装：封装是面向对象编程的基础。封装指的是将相关的数据和方法封装在一起，对外部提供一个简单的接口来访问对象的内部状态和行为。这种方式可以隐藏对象的内部复杂性，并且保护数据安全性。</p></li><li><p>继承：继承指的是一个对象从它的父类（或者基类）中获得了属性和方法。继承允许我们从现有的类中派生出一个新的类，并且在不影响原有类的情况下增加其功能。这样做减少了重复代码的编写，提高了代码的可重用性和可维护性。</p></li><li><p>多态：多态是面向对象编程的另一个重要特点。多态意味着同一个方法在不同的对象上具备不同的行为，这种方式可以提高程序的灵活性和扩展性。多态有两种实现方式：重载和重写。重载是在同一个对象中使用不同的参数调用同一个方法；重写是在不同的对象中，使用相同的方法名和参数列表来重写实现。</p></li></ol><p>这三个特点相互补充，互相依赖，一起构成了面向对象编程的核心思想和优势。</p><h3 id="面向对象的特点" tabindex="-1">面向对象的特点 <a class="header-anchor" href="#面向对象的特点" aria-label="Permalink to &quot;面向对象的特点&quot;">​</a></h3><p>面向对象编程的特点有以下几个方面：</p><ol><li><p>封装：将数据和方法封装成对象，隐藏内部的状态和实现细节，只暴露必要的接口。这样可以降低耦合度，提高代码的可维护性和安全性。</p></li><li><p>继承：通过继承机制，可将已有的类作为基础，派生出新的类来。继承能够大大减少代码的重复性，提高可维护性和可扩展性。</p></li><li><p>多态：同一种行为作用在不同的对象上时，会产生不同的结果。多态可以通过接口、抽象类和虚函数等实现。</p></li><li><p>抽象：抽象是指忽略一个实体的特定属性，而只关注它的一般特征，将其作为一个独立的概念进行处理。</p></li><li><p>组合：组合可以让一个对象成为另一个对象的一部分。组合是面向对象设计模式中一个很重要的概念，借助组合可以很好地实现代码的复用和拓展。</p></li></ol><h2 id="统一建模语言" tabindex="-1">统一建模语言 <a class="header-anchor" href="#统一建模语言" aria-label="Permalink to &quot;统一建模语言&quot;">​</a></h2><p>统一建模语言（Unified Modeling Language，简称UML）是一种用于描述和建模软件系统的标准化语言。UML最初由Grady Booch、James Rumbaugh和Ivar Jacobson等人于1994年共同开发，目的是将各种现有的面向对象建模方法进行集成和统一。</p><p>UML提供了大量的符号和术语，可以用来描述软件系统的结构、行为、交互和功能等方面。使用UML可以帮助开发人员更好地理解需求、设计、编码和测试系统，并且可以使团队之间的沟通更加精确和高效。</p><p>UML包括结构图和行为图两种类型。结构图包括类图、对象图、包图、组件图、部署图等；行为图包括用例图、活动图、状态图、序列图、协作图等。这些图形工具可以帮助开发人员更好地理解系统的不同层面，并支持开发的各个阶段。</p><p>UML已经成为一个被广泛使用的开发工具，它已经成为了软件工程中的重要标准。许多软件开发工具和集成开发环境都支持UML，并提供了可视化建模工具，方便开发人员进行建模、设计和分析。使用UML，可以帮助开发人员更好地管理和维护复杂的软件系统。</p><h3 id="同意建模语言的结构" tabindex="-1">同意建模语言的结构 <a class="header-anchor" href="#同意建模语言的结构" aria-label="Permalink to &quot;同意建模语言的结构&quot;">​</a></h3><ul><li>[ ] **元介质模型层：**该层描述基本的类型、属性、关系，这些元素都用于定义UML元模型。元介质模型强调用少数功能较强的模型成分来组合表达复杂的语义。每一个方法和技术都应在相对独立的抽象层次上。</li><li>[ ] **元模型层：**该层组成了UML的基本元素，包括面向对象和面向组件的概念，这一层的每个概念都在元介质模型的“事物”的实例中。</li><li>[ ] **模型层该层：**组成了UML的模型，这一层中的每个概念都是在元模型层中概念的一个实例，这一层的模型通常叫作类模型或类型模型。</li><li>[ ] **用户模型层该层：**中的所有元素都是UML模型的例子。这一层中的每个概念都是模型层的一个实例，也是元模型层的一个实例。这一层的模型通常叫作对象模型或实例模型。</li></ul><p>UML使用模型来描述系统的结构或静态特征，以及行为或动态特征，它通过不同的视图来体现行为或动态特征。常用的视图有以下几种：</p><p>（1）**用例视图：**该视图强调以用户的角度所看到的或需要的系统功能为出发点建模。这种视图有时也被称为用户模型视图。</p><p>（2）**逻辑视图：**该视图用于展现系统的静态和结构组成及其特征，它也被称为结构模型视图或静态视图。</p><p>（3）**并发视图：**该视图体现了系统的动态或者行为特征，它也被称为行为模型视图、过程视图、写作视图或者动态视图。</p><p>（4）**组件视图：**该视图体现了系统实现的结构和行为特征，它有时也被称为模型实现视图。</p><p>（5）**开发视图：**该视图体现了系统实现环境的结构和行为特征，它也被称为物理视图。</p><h3 id="面向对象的建模" tabindex="-1">面向对象的建模 <a class="header-anchor" href="#面向对象的建模" aria-label="Permalink to &quot;面向对象的建模&quot;">​</a></h3><p>面向对象的建模是一种新的思维方式，是一种关于计算机和信息结构化的新思维。面向对象的建模，把系统看作相互协作的对象，这些对象是结构和行为的封装，都属于某个类，那些类具有某种层次化的结构。系统的所有功能通过对象之间相互发送消息来获得。面向对象的建模可以视为一个包含以下元素的概念框架：抽象、封装、模块化、层次、分类、并行、稳定、可重用性和可扩展性。</p><h2 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h2><h3 id="类概述" tabindex="-1">类概述 <a class="header-anchor" href="#类概述" aria-label="Permalink to &quot;类概述&quot;">​</a></h3><p>面向对象中的对象需要通过定义类来声明，对象一词是一种形象的说法，在编写代码过程中则是通过定义一个类来实现。</p><p>类的层次关系</p><p><img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/software/install/teamcity/202305231157651.png" alt=""></p><p>类是一个新的数据类型，它和结构体有些相似，是由不同数据类型组成的集合体，但类要比结构体增加了操作数据的行为，这个行为就是函数。</p><h3 id="类的声明与定义" tabindex="-1">类的声明与定义 <a class="header-anchor" href="#类的声明与定义" aria-label="Permalink to &quot;类的声明与定义&quot;">​</a></h3><p>格式：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class 类名标识符</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    [public:]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [数据成员的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [成员函数的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [private:]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [数据成员的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [成员函数的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [protected:]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [数据成员的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [成员函数的声明]</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>类的声明格式的说明如下：</p><ul><li>class是定义类结构体的关键字，大括号内被称为类体或类空间。</li><li>类名标识符指定的就是类名，类名就是一个新的数据类型，通过类名可以声明对象。</li><li>类的成员有数据和函数两种类型</li><li>大括号内是定义和声明类成员的地方，关键字public、private、protected的类成员访问的修饰符。</li></ul><p>类中对的数据成员的类型是可以是任意的，包含整型，浮点型，字符型，数组，指针和引用，而自身类的指针或引用又是可以作为该类的成员的。</p><h3 id="类的实现" tabindex="-1">类的实现 <a class="header-anchor" href="#类的实现" aria-label="Permalink to &quot;类的实现&quot;">​</a></h3><p>第一种方法是将类的成员函数都定义在类体内。</p><p>第二种方法是将类的成员函数都定义在类体外。但需要使用<code>::</code>,来运算</p><div class="tip custom-block"><p class="custom-block-title">说明</p><p>(1)类的数据成员需要初始化，成员函数害要添加实现代码。类的数据成员不可以在类的声明中初始化。</p><p>(2)空类是C++中最简单的类，其声明格式为<code>class CPerson{};</code>,空类只是起到占位的作用，需要的时候在定义类成员及实现.</p></div><h3 id="对象的声明" tabindex="-1">对象的声明 <a class="header-anchor" href="#对象的声明" aria-label="Permalink to &quot;对象的声明&quot;">​</a></h3><p>定义一个新类后，就可以通过类名来声明一个对象。格式：<code>类名 对象名表</code></p><p>类名是定义好的新类的标识符，对象名表中是一个或多个对象的名称，如果声明的是多个对象就用都好运算符分隔。</p><p>声明完对象，就是对象的引用了，对象的引用有两种方式，一种是成员引用方式，一种是对象指针方式。</p><p>（1）成员引用方式</p><p>成员变量引用的格式<code>对象名.成员名</code>,这里，“.” 是一个运算符，该运算符的功能是表示对象的成员。</p><p>成员函数引用的表示如下：<code>对象名.成员名（参数表）</code></p><p>（2）对象指针方式：</p><p>对象声明形式中的对象名表，除了是用逗号运算符分隔的多个对象名外，还可以是对象名数组、对象名指针和引用形式的对象名</p><p>声明一个对象指针：<code>CPerson *p;</code></p><p>但要想使用对象的成员，需要“-&gt;”运算符，它是表示成员的运算符，与“.”运算符的意义相同。“-&gt;”用来表示对象指针所指的成员，对象指针就是指向对象的指针。</p><h2 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h2><h3 id="构造函数概述" tabindex="-1">构造函数概述 <a class="header-anchor" href="#构造函数概述" aria-label="Permalink to &quot;构造函数概述&quot;">​</a></h3><p>在类的实例进入其作用域时，依旧是建立一个对象，构造函数就会被调用，那么构造函数的作用是什么呢？当建立一个对象时，常常需要做某些初始化的工作，例如，对数据成员进行赋值设置类的属性，而这些操作刚好放在构造函数中完成。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">// 定义CPerson类</span></span>
<span class="line"><span style="color:#e1e4e8;">class CPerson</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson();</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson(int iIndex, short m_shAge, double m_dSalary);</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">    double m_dSalary;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int getIndex();</span></span>
<span class="line"><span style="color:#e1e4e8;">    short getAge();</span></span>
<span class="line"><span style="color:#e1e4e8;">    double getSalary();</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">// 在默认构造函数中初始化</span></span>
<span class="line"><span style="color:#e1e4e8;">CPerson::CPerson()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_iIndex = 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_shAge = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_dSalary = 1000;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 在带参数的构造函数中初始化</span></span>
<span class="line"><span style="color:#e1e4e8;">CPerson::CPerson(int iIndex, short m_shAge, double m_dSalary)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_iIndex = iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_shAge = m_shAge;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_dSalary = m_dSalary;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int CPerson::getIndex()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return m_iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 在 main 函数中输出类的成员值</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson p1;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;m_iIndex is:&quot; &lt;&lt; p1.getIndex() &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson p2(1.20, 1000);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;m_iIndex is: &quot; &lt;&lt; p2.getIndex() &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h3 id="复制构造函数" tabindex="-1">复制构造函数 <a class="header-anchor" href="#复制构造函数" aria-label="Permalink to &quot;复制构造函数&quot;">​</a></h3><p>在开发程序是可能需要保存对象的副本，以便在后面执行的过程中恢复对象的状态，那么如何用一个已经初始化的对象来新生成一个一摸一样的对象？答案是使用复制构造函数就是函数的参数是一个已经初始化的类对象。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 使用复制构造函数</span></span>
<span class="line"><span style="color:#e1e4e8;">class CPerson </span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson(int iIndex, short shAge, double dSalary); // 构造函数</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson(CPerson &amp; copyPerson); // 复制构造函数</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">    short m_shAge;</span></span>
<span class="line"><span style="color:#e1e4e8;">    double m_dSalary;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int getIndex();</span></span>
<span class="line"><span style="color:#e1e4e8;">    short getAge();</span></span>
<span class="line"><span style="color:#e1e4e8;">    double getSalary();</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 构造函数</span></span>
<span class="line"><span style="color:#e1e4e8;">CPerson::CPerson(CPerson &amp; copyPerson)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_iIndex = copyPerson.m_iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_shAge = copyPerson.m_shAge;</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_dSalary = copyPerson.m_dSalary;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">short CPerson::getAge()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return m_shAge;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int CPerson::getIndex()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return m_iIndex;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">double CPerson::getSalary()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return m_dSalary();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 在主程序中实现类对象的调用</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;Person.h&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace stdl;</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson p2(200,30,100);</span></span>
<span class="line"><span style="color:#e1e4e8;">    Cperson p2(p1);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;m_iINdex of p1 is:&quot; &lt;&lt; p2.getIndex() &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h3 id="析构函数" tabindex="-1">析构函数 <a class="header-anchor" href="#析构函数" aria-label="Permalink to &quot;析构函数&quot;">​</a></h3><p>构造函数和析构函数是类体定义中比较特殊的来给你个成员函数，因为他们两个都没有返回值，而且构造函数名标识符和类名标识符相同，析构函数名标识符就是在类名标识符前面加~符号。</p><p>构造函数主要用来在对象创建时，给丢向中的一些数据成员赋值，主要目的就是来初始化对象。析构函数的功能是用来释放一个对象，在对象昂删除前，用它来做一些清理工作，它与构造函数的功能正好相反。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 使用析构函数</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;isotream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;string.h&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">class CPerson</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson(); // 构造函数</span></span>
<span class="line"><span style="color:#e1e4e8;">    ~CPerson(); // 析构函数</span></span>
<span class="line"><span style="color:#e1e4e8;">    char *m_pMessage;</span></span>
<span class="line"><span style="color:#e1e4e8;">    void ShowStartMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">    void ShowFrameMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">CPerson::CPerson()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    m_pMessage = new char[2048];</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void CPerson::ShowStartMessage()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(m_pMessage, &quot;Welcome to MR&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; m_pMessage &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void CPerson::ShowFrameMessage()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; m_pMessage &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">CPerson::~CPerson()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    delete[] m_pMessage;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 在主程序中调用</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &quot;Person.h&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CPerson p;</span></span>
<span class="line"><span style="color:#e1e4e8;">    p.ShowFrameMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">    p.ShowStartMessage();</span></span>
<span class="line"><span style="color:#e1e4e8;">    p.ShowFrameMesssage();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">/*</span></span>
<span class="line"><span style="color:#e1e4e8;">程序在构造函数中使用new为成员m_pMessage分配空间，在析构函数中使用delete释放由new分配的空间。成员m_pMessage为字符指针，在ShowStartMessage成员函数中输出字符指针所指向的内容。</span></span>
<span class="line"><span style="color:#e1e4e8;">*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><div class="danger custom-block"><p class="custom-block-title">注意事项</p><ul><li>一个类中只可能定义一个析构函数</li><li>析构函数不能重载</li><li>构造函数和析构函数不能使用return语句返回值，不用加上关键字void</li></ul></div><p>构造函数和析构函数的调用环境：</p><p>（1）自动变量的作用域是某个模块，当此模块被激活时，自动变量调用构造函数，当推出此模块时，会调用析构函数。</p><p>（2）全局变量在进入main函数之前会调用构造函数，在程序终止时会调用析构函数</p><p>（3）动态分配的对象在使用new为对象分配内存是会调用构造函数；使用delete删除对象时会调用析构函数</p><p>（4）临时变量是为支持计算，有编译器自动产生的。临时变量的生存期的开始和结尾会调用构造函数和析构函数。</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><h2 id="类成员" tabindex="-1">类成员 <a class="header-anchor" href="#类成员" aria-label="Permalink to &quot;类成员&quot;">​</a></h2><h3 id="访问类成员" tabindex="-1">访问类成员 <a class="header-anchor" href="#访问类成员" aria-label="Permalink to &quot;访问类成员&quot;">​</a></h3><p>类的三大特点之一就是具有封装性，封装在类里面的数据可以设置成对外可见或不可见，通过关键字public、private、protected可以设置类中数据成员对外是否可见，也就是其他类是否可以访问呢该数据成员。</p><p>关键字public、private、protected说明类成员是共有的、私有的、还是保护的。这3个关键字将类划分为3个区域，在public区域的类成员可以在类作用域外被访问，而private区域和protected区域之呢个在类作用域内被访问。</p><p>这3种类成员的属性如下：</p><ul><li>public属性的成员对外可见，对内可见。</li><li>private属性的成员对外不可见，对内可见。</li><li>protected属性的成员对外不可见，对内可见，且对派生类是可见的。</li></ul><h3 id="内联成员函数" tabindex="-1">内联成员函数 <a class="header-anchor" href="#内联成员函数" aria-label="Permalink to &quot;内联成员函数&quot;">​</a></h3><p>在定义函数时，可以使用inline关键字将函数定义为内联函数。在定义类的成员函数时，也可以使用inline关键字将成员函数定义为内联成员函数。其实，对于成员函数来说，如果其定义是在类体中，即使没有使用inline关键字，该成员函数也被认为是内联成员函数</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class CUser </span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Username[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    public: </span></span>
<span class="line"><span style="color:#e1e4e8;">    inline char *GetUsername()const; // 定义一个内联成员函数</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">char *CUser::GetUsername()const  // 实现内联成员函数</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return (char *)m_Username;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 程序中，使用inline关键字将类中的成员函数设置为内联成员函数。此外，也可以在类成员函数的实现部分使用inline关键字表示函数为内联成员函数。</span></span>
<span class="line"><span style="color:#e1e4e8;">class CUser</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Username[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    public: </span></span>
<span class="line"><span style="color:#e1e4e8;">    char *GetUsername()const; // 定义成员函数</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">inline char *CUser::GetUsername()const  // 函数为内联成员函数</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return (char *)m_Username; // 设置返回值</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">// 程序中的代码演示了在何处使用关键字inine，对于内联函数来说，程序会在函数调用的地方直接插入函数代码，如果函数体语句比较多，则会导致程序代码膨胀，如果将类的析构函数定义为内联函数，可能会导致潜在的代码膨胀。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="静态类成员" tabindex="-1">静态类成员 <a class="header-anchor" href="#静态类成员" aria-label="Permalink to &quot;静态类成员&quot;">​</a></h3><p>如果将类成员定义为静态成员，则允许使用类名直接访问。静态类成员是在类成员定义前使用static关键字标识。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class CBook</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    static unsigned int m_Price; // 定义一个静态数据成员</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在定义静态数据成员时，通常需要在类体外部对静态数据成员进行初始化。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">unsigned int CBook::m_Price = 10;  // 初始化静态数据成员</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>对于静态成员来说，不仅可以通过对象访问，还可直接使用类名访问</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">int mian()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CBook book;</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; CBook::m_Prive &lt;&lt; endl;  // 通过类名访问静态成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; book.m_Prive &lt;&lt; endl;    // 通过对象访问静态成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="danger custom-block"><p class="custom-block-title">注意</p><p>(1) 静态数据成员可以是当前类的类型，而其他数据成员只能是当前类的指针或引用类型</p><p>(2) 惊天数据成员可以作为成员函数的默认参数。</p></div><h3 id="隐藏的this指针" tabindex="-1">隐藏的this指针 <a class="header-anchor" href="#隐藏的this指针" aria-label="Permalink to &quot;隐藏的this指针&quot;">​</a></h3><p>对于类的非静态成员，每一个对象都有自己的一份拷贝，即每个对象都有自己的数据成员，不过成员函数确实每个对象那个共享的，那么调用共享的成员函数是如何找到自己的数据成员呢？答案就是通过类中隐藏的this指针。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class CBook</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_Pages;</span></span>
<span class="line"><span style="color:#e1e4e8;">    void OutputPages()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Pages &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">int main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CBook vbBook,vcBook;</span></span>
<span class="line"><span style="color:#e1e4e8;">    vbBook.m_Pages = 512;</span></span>
<span class="line"><span style="color:#e1e4e8;">    vcBook.m_Pages = 570;</span></span>
<span class="line"><span style="color:#e1e4e8;">    vbBook.OutputPages();</span></span>
<span class="line"><span style="color:#e1e4e8;">    vcBook.OutputPages();</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="嵌套类" tabindex="-1">嵌套类 <a class="header-anchor" href="#嵌套类" aria-label="Permalink to &quot;嵌套类&quot;">​</a></h3><p>在一个类中定义另一个类，这被称为嵌套类。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#define MAXLEN 128</span></span>
<span class="line"><span style="color:#e1e4e8;">class CList</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">	public: </span></span>
<span class="line"><span style="color:#e1e4e8;">    class CNode</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        friend class CList; // 将CList类作为自己的友元类</span></span>
<span class="line"><span style="color:#e1e4e8;">        private:</span></span>
<span class="line"><span style="color:#e1e4e8;">        int m_Tag;</span></span>
<span class="line"><span style="color:#e1e4e8;">        public: </span></span>
<span class="line"><span style="color:#e1e4e8;">        char m_Name[MAXLEN];</span></span>
<span class="line"><span style="color:#e1e4e8;">    };</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    CNode m_Node;</span></span>
<span class="line"><span style="color:#e1e4e8;">    void SetNodeName(const char *pchData)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        if(pchData != NULL)</span></span>
<span class="line"><span style="color:#e1e4e8;">        {</span></span>
<span class="line"><span style="color:#e1e4e8;">            strcpy(m_Node.m_Name, pchData); //访问CNode类的共有数据</span></span>
<span class="line"><span style="color:#e1e4e8;">        }</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    void SetNodeTag(int tag)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        m_Node.m_Tag = tag; // 访问CNode类的私有数据</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="局部类" tabindex="-1">局部类 <a class="header-anchor" href="#局部类" aria-label="Permalink to &quot;局部类&quot;">​</a></h3><p>类的定义可以放在头文件中，也可以放在源文件中。还有一种情况，类的定义也可以放置在函数中，这样的类被称为局部类。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">void LocalClass()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    class CBook</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        private:</span></span>
<span class="line"><span style="color:#e1e4e8;">        int m_Pages;</span></span>
<span class="line"><span style="color:#e1e4e8;">        public:</span></span>
<span class="line"><span style="color:#e1e4e8;">        void  SetPages(int page)</span></span>
<span class="line"><span style="color:#e1e4e8;">        {</span></span>
<span class="line"><span style="color:#e1e4e8;">            if(m_Pages != page)</span></span>
<span class="line"><span style="color:#e1e4e8;">            {</span></span>
<span class="line"><span style="color:#e1e4e8;">                m_Pages = page;</span></span>
<span class="line"><span style="color:#e1e4e8;">            }</span></span>
<span class="line"><span style="color:#e1e4e8;">        }</span></span>
<span class="line"><span style="color:#e1e4e8;">        int GetPages()</span></span>
<span class="line"><span style="color:#e1e4e8;">        {</span></span>
<span class="line"><span style="color:#e1e4e8;">            return m_Pages;</span></span>
<span class="line"><span style="color:#e1e4e8;">        }</span></span>
<span class="line"><span style="color:#e1e4e8;">    };</span></span>
<span class="line"><span style="color:#e1e4e8;">    CBook book;</span></span>
<span class="line"><span style="color:#e1e4e8;">    book.SetPages(300);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; book.GetPages() &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="友元" tabindex="-1">友元 <a class="header-anchor" href="#友元" aria-label="Permalink to &quot;友元&quot;">​</a></h2><h3 id="友元概述" tabindex="-1">友元概述 <a class="header-anchor" href="#友元概述" aria-label="Permalink to &quot;友元概述&quot;">​</a></h3><p>在讲述类的内容时说明了隐藏数据成员的好处，但是有些时候，类会允许一些特殊的函数直接读写其私有数据成员。使用friend关键字可以让特定的函数或者别的类的所有成员函数对私有数据成员进行读写，这既可以保持数据的私有性，又能够使特定的类或函数直接访问私有数据。有时候，普通函数需要直接访问一个类的保护或私有数据成员。如果没有友元机制，则只能将类的数据成员声明为公共的，从而任何函数都可以无约束地访问它。普通函数需要直接访问类的保护或私有数据成员的原因主要是为提高效率。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 友元的简单使用</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;isotream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">class CRectangle</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    CRectangle()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        m_iHeight = 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">        m_iWidth = 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    CRectangle(int iLeftTop_x, int iLeftTop_y,int iRightBottom_x,int iRightBottom_y)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        m_iHeight = iRightBottom_y - iLeftTp_y;</span></span>
<span class="line"><span style="color:#e1e4e8;">        m_iWidth = iRightBottom_x - iLeftTop_x;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    int getHeight()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return m_iHeight;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    int getWidth()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return m_iWidth;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    friend int ComputerRectArea(CRectangle &amp; myRect); // 声明为友元函数</span></span>
<span class="line"><span style="color:#e1e4e8;">    protected:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_iHeight;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_iWidth;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">int ComputerRectArea(CRectangle &amp; myRect)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    return myRect.m_iHeight*myRect.m_iWidth;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    CRetangel rg(0,0,100,100);</span></span>
<span class="line"><span style="color:#e1e4e8;">    cout &lt;&lt; &quot;Resutl of computerRectArea is : &quot; &lt;&lt; ComputerRectArea(rg) &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h3 id="友元类" tabindex="-1">友元类 <a class="header-anchor" href="#友元类" aria-label="Permalink to &quot;友元类&quot;">​</a></h3><p>友元类：在一个类中使用friend关键字声明另一个类是其友元类，该类的所有成员函数都可以访问其友元类的私有和保护成员。但是需要注意，友元关系不可传递和继承，即友元的友元不一定是自己的友元，子类也不一定可以访问其父类的友元成员。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class A {</span></span>
<span class="line"><span style="color:#e1e4e8;">friend class B; // B是A的友元类</span></span>
<span class="line"><span style="color:#e1e4e8;">private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int a;</span></span>
<span class="line"><span style="color:#e1e4e8;">protected:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int b;</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int c;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class B {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void func(A&amp; obj) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        obj.a = 1; // 访问A的私有成员</span></span>
<span class="line"><span style="color:#e1e4e8;">        obj.b = 2; // 访问A的保护成员</span></span>
<span class="line"><span style="color:#e1e4e8;">        obj.c = 3; // 访问A的公有成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>当使用友元类时，需要注意以下几点：</p><ol><li><p>友元关系不可传递和继承。虽然类A是类B的友元类，并且类B是类C的友元类，但并不意味着类A是类C的友元类。同样，子类不一定可以访问其父类的友元成员。</p></li><li><p>友元类不是该类的成员，也不在该类的命名空间中。因此，在定义成员函数时，不需要使用类限定符。</p></li><li><p>友元类的声明更多的是针对编译器，方便编译器检查和解析。它并不会影响程序的运行时行为或性能。</p></li><li><p>友元类的使用可能降低程序的封装性和可维护性。因为它打破了类的访问限制，增加了代码的耦合度，需要在设计时考虑清楚。</p></li><li><p>在使用友元类时，需要认真考虑安全风险。如果未经允许的类可以访问另一个类的私有成员，可能会导致安全问题或数据泄露。</p></li></ol><p>综上所述，友元类是一种有用的机制，可以提高程序的灵活性和效率，但需要在设计时慎重使用，避免出现潜在的安全问题。</p></div><h3 id="友元方法" tabindex="-1">友元方法 <a class="header-anchor" href="#友元方法" aria-label="Permalink to &quot;友元方法&quot;">​</a></h3><p>友元方法：在一个类中使用friend关键字声明一个函数是其友元方法，该函数可以访问该类的私有和保护成员。需要注意的是，友元方法不是该类的成员函数，也不在该类的命名空间中。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class A {</span></span>
<span class="line"><span style="color:#e1e4e8;">friend void func(A&amp; obj); // func是A的友元方法</span></span>
<span class="line"><span style="color:#e1e4e8;">private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int a;</span></span>
<span class="line"><span style="color:#e1e4e8;">protected:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int b;</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int c;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">void func(A&amp; obj) {</span></span>
<span class="line"><span style="color:#e1e4e8;">    obj.a = 1; // 访问A的私有成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    obj.b = 2; // 访问A的保护成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    obj.c = 3; // 访问A的公有成员</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    A obj;</span></span>
<span class="line"><span style="color:#e1e4e8;">    func(obj); // 调用友元函数func来访问A中的成员</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>在使用友元方法时，需要注意以下几点：</p><ol><li><p>友元方法不是该类的成员函数，也不在该类的命名空间中。因此，在定义友元函数时，需要使用函数形式声明，而不是成员函数形式声明。同时，在调用友元函数时需要显式地指明函数名和参数。</p></li><li><p>友元方法可能降低程序的封装性和可维护性。因为它打破了类的访问限制，增加了代码的耦合度。在设计时需要评估使用友元方法的风险和收益。</p></li><li><p>友元方法只能访问该类的私有成员和保护成员。如果需要访问类的公有成员，可以考虑将友元函数定义为该类的成员函数。</p></li><li><p>友元方法可以被多个类声明为友元函数，但同一个类中只能有一个友元函数。如果需要定义多个友元函数，可以通过重载函数名和参数列表来实现。</p></li><li><p>在使用友元方法时需要认真考虑安全风险。如果未经允许的函数可以访问另一个类的私有成员，可能会导致安全问题或数据泄露。</p></li></ol><p>综上所述，友元方法是一种特殊的机制，可以提高程序的灵活性和效率，但需要在设计时慎重使用，避免出现潜在的安全问题。</p></div><h2 id="命明空间" tabindex="-1">命明空间 <a class="header-anchor" href="#命明空间" aria-label="Permalink to &quot;命明空间&quot;">​</a></h2><h3 id="使用命名空间" tabindex="-1">使用命名空间 <a class="header-anchor" href="#使用命名空间" aria-label="Permalink to &quot;使用命名空间&quot;">​</a></h3><p>在一个应用程序的多个文件中可能会存在同名的全局对象，这样会导致应用程序的连接错误。使用命名空间是消除命名冲突的最佳方式。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">namespace MyName1</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt1 = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt2 = 20;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">namespace MyName2</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt1 = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt2 = 20;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// namespace 是关键字，</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>总而言之，命名空间就是一个命名的范围区域。</p><h3 id="定义命名空间" tabindex="-1">定义命名空间 <a class="header-anchor" href="#定义命名空间" aria-label="Permalink to &quot;定义命名空间&quot;">​</a></h3><p>格式：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">namespace 名称</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    常量、变量、函数对象的定义</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">// 例如</span></span>
<span class="line"><span style="color:#e1e4e8;">namespace MyName</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt1 = 10;</span></span>
<span class="line"><span style="color:#e1e4e8;">    int iInt2 = 20;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>命名空间定义完成，如何使用其中的成员呢？在讲解类时曾介绍过使用作用域限定符“::”来引用类中的成员，在这里依然使用“::”来引用空间中的成员。引用空间成员的一般形式如下：<code>命名空间名称::成员</code></p><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h2><p>继承（inheritance）是面向对象的主要特征（此外还有封装和多态）之一，它使得一个类可以从现有类中派生，而不必重新定义一个新类。继承的实质就是用已有的数据类型创建新的数据类型，并保留已有数据类型的特点，以旧类为基础创建新类，新类包含了旧类的数据成员和成员函数，并且可以在新类中添加新的数据成员和成员函数。旧类被称为基类或父类，新类被称为派生类或子类。</p><h3 id="类的继承" tabindex="-1">类的继承 <a class="header-anchor" href="#类的继承" aria-label="Permalink to &quot;类的继承&quot;">​</a></h3><p>形式;</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class 派生类名称: [继承方式] 基类名标识符</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    [访问控制修饰符:]</span></span>
<span class="line"><span style="color:#e1e4e8;">    [成员声明列表]</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>继承方式有3种派生类型，分别为共有（public）型、保护（protected）型和私有（private）型，访问控制修饰符也是public、protected、private3种类型，成员声明列表中包含类的成员变量及成员函数，是派生类新增的成员。&quot;:&quot;是一个运算符，表示基类和派生类之间的继承关系。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 定义一个员工类</span></span>
<span class="line"><span style="color:#e1e4e8;">class CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_ID;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Name[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Depart[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">// 定义一个操作员类</span></span>
<span class="line"><span style="color:#e1e4e8;">class COperator :public CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    bool Login();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 已公有方式继承</span></span>
<span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_ID;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Name[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Depart[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    CEmployee()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        memset(m_Name,0,128); // 初始化m_Name</span></span>
<span class="line"><span style="color:#e1e4e8;">        memset(m_Depart,0,128); // 初始化Depart</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    void OutputName()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;员工姓名&quot; &lt;&lt; m_Name &lt;&lt; endl; // 输出员工姓名</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">class COperator :public CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    bool Login()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        if(strcmp(m_Name, &quot;MR&quot;) == 0 &amp;&amp; strcmp(m_Password,&quot;KJ&quot;) == 0)</span></span>
<span class="line"><span style="color:#e1e4e8;">        {</span></span>
<span class="line"><span style="color:#e1e4e8;">            cout &lt;&lt; &quot;登录成功&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">            return true;</span></span>
<span class="line"><span style="color:#e1e4e8;">        }else</span></span>
<span class="line"><span style="color:#e1e4e8;">        {</span></span>
<span class="line"><span style="color:#e1e4e8;">            cout &lt;&lt; &quot;登录失败！&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">            return false;</span></span>
<span class="line"><span style="color:#e1e4e8;">        }</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int mian()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    COperator optr;</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(optr.m_Name, &quot;MR&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    strcpy(optr.m_Password, &quot;KJ&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    optr.Login();</span></span>
<span class="line"><span style="color:#e1e4e8;">    optr.OutputName();</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h3 id="继承后可访问性" tabindex="-1">继承后可访问性 <a class="header-anchor" href="#继承后可访问性" aria-label="Permalink to &quot;继承后可访问性&quot;">​</a></h3><p>继承方式有public、private、protected。</p><p>（1）公有型派生</p><p>公有型派生表示对于基类中的public数据成员和成员函数，在派生类中仍然是public；对于基类中的private数据成员和成员函数，在派生类中仍然是private，例如：</p><div class="language-C++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">C++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void Output()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_ID &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Depart &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_ID;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Name[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Depart[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">class COperator :public CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void Output()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_ID &lt;&lt; endl;  // 错误</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; endl;// 错误</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Depart &lt;&lt; ednl;// 错误</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Password &lt;&lt; endl; // 正确</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    bool Login();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>（2）私有型派生类</p><p>私有型派生表示对于基类中的public、protected数据成员和成员函数，在派生类中可以访问。基类中的private数据成员，在派生类中不可以访问，例如：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void Output()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_ID &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Depart &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;"> </span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_ID;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Name[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Depart[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">class COperator :public CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void Output()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_ID &lt;&lt; endl;  // 正确</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; endl;// 正确</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Depart &lt;&lt; ednl;// 错误</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Password &lt;&lt; endl; // 正确</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    bool Login();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>（3）保护型派生类</p><p>保护型派生表示对于基类中的public、protected数据成员和成员函数，在派生类中均为protected。protected类型在派生类的定义时可以访问，用派生类声明的对象不可以访问，也就是说在类体外不可以访问。protected成员可以被基类的所有派生类使用，这一性质可以沿继承树无限向下传播。因为保护类的内部数据不能被随意更改，实例类本身负责维护，这就起到很好的封装性作用。把一个类分作两部分，一部分是公共的，另一部分是保护，保护成员对于使用者来说是不可见的，也是不需了解的，这就减少了类与其他代码的关联程度。类的功能是独立的，它不依赖于应用程序的运行环境，既可以放到这个程序中使用，也可以放到那个程序中使用，这就能够非常容易地用一个类替换另一个类。类访问限制的保护机制使人们编制的应用程序更加可靠和易维护。</p><h3 id="构造函数访问顺序" tabindex="-1">构造函数访问顺序 <a class="header-anchor" href="#构造函数访问顺序" aria-label="Permalink to &quot;构造函数访问顺序&quot;">​</a></h3><p>由于父类和子类中都有构造函数和析构函数，因此子类对象在创建时是父类先进行构造，还是子类先进行构造？同样在子类对象释放时，是父类先进行释放，还是子类先进行释放？这都有个先后顺序问题。答案是当从父类派生一个子类并声明一个子类的对象时，它将先调用父类的构造函数，然后调用当前类的构造函数来创建对象；在释放子类对象时，先调用的是当前类的析构函数，然后是父类的析构函数。</p><h3 id="子类显示调用父类构造函数" tabindex="-1">子类显示调用父类构造函数 <a class="header-anchor" href="#子类显示调用父类构造函数" aria-label="Permalink to &quot;子类显示调用父类构造函数&quot;">​</a></h3><p>当父类含有带参数的构造函数时，子类创建的时候会调用它么？答案是通过显示方式才可以调用。</p><p>无论创建子类对象时，调用的是哪种子类构造函数，都会自动调用父类默认构造函数。若想使用父类带参数的构造函数，则需要显示的方式。</p><p>当父类只有带参数的构造函数时，子类必须以显示方法调用父类带参数的构造函数，否则编译会出现错误。</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">using namespace std;</span></span>
<span class="line"><span style="color:#e1e4e8;">class CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int m_ID;</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Name[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Depart[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    CEmployee(char name[])</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        srtcpy(m_Name,name);</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; &quot;调用了CEmployee类带参数的构造函数&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    CEmployee()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        strcpy(m_Name, &quot;MR&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; m_Name &lt;&lt; &quot;CEmployee类无参构造函数被调用&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    ~CEmployee()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;CEmployee类析构函数被调用&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">class COperator :public CEmployee</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    char m_Password[128];</span></span>
<span class="line"><span style="color:#e1e4e8;">    COperator(char name[]):CEmployee(name)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;COperator 类构造函数被调用&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    COperator():CEmployee(&quot;JACK&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;COperator 类构造函数被调用&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">        </span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    ~COperator()</span></span>
<span class="line"><span style="color:#e1e4e8;">    {</span></span>
<span class="line"><span style="color:#e1e4e8;">        cout &lt;&lt; &quot;COperator 类构造函数被调用&quot; &lt;&lt; endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">int main()</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">    COperator optr1;</span></span>
<span class="line"><span style="color:#e1e4e8;">    Coperator optr2(&quot;LaoZhang&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h3 id="子类隐藏父类的成员函数" tabindex="-1">子类隐藏父类的成员函数 <a class="header-anchor" href="#子类隐藏父类的成员函数" aria-label="Permalink to &quot;子类隐藏父类的成员函数&quot;">​</a></h3><p>如果子类中定义了一个和父类一样的成员函数，那么一个子类对象是调用父类中的成员函数，还是调用子类中的成员函数呢？答案是调用子类中的成员函数。</p><h2 id="重载运算符" tabindex="-1">重载运算符 <a class="header-anchor" href="#重载运算符" aria-label="Permalink to &quot;重载运算符&quot;">​</a></h2><h3 id="重载运算符的必要性" tabindex="-1">重载运算符的必要性 <a class="header-anchor" href="#重载运算符的必要性" aria-label="Permalink to &quot;重载运算符的必要性&quot;">​</a></h3><p>重载运算符是C++中面向对象编程的一个重要特性，它允许程序员自定义类的运算符行为，使类的使用更加方便和直观。C++中有一些内置运算符，例如加减乘除等，重载这些运算符可以使类对象的操作更加符合实际需求，提高代码的复用性和可维护性。</p><p>一方面，重载运算符可以使类对象操作更加方便。例如在字符串类中重载+运算符，可以将两个字符串拼接在一起：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class String {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    String operator+(const String&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        String result;</span></span>
<span class="line"><span style="color:#e1e4e8;">        result.str = str + other.str;</span></span>
<span class="line"><span style="color:#e1e4e8;">        return result;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    std::string str;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">String s1{&quot;hello&quot;};</span></span>
<span class="line"><span style="color:#e1e4e8;">String s2{&quot;world&quot;};</span></span>
<span class="line"><span style="color:#e1e4e8;">String s3 = s1 + s2; // 可以使用+号来将两个字符串拼接起来</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>另一方面，重载运算符可以提高代码的复用性和可维护性。例如在矩阵类中重载*运算符，可以将两个矩阵相乘，代码清晰简洁，易于维护：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class Matrix {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Matrix operator*(const Matrix&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        Matrix result;</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 将两个矩阵相乘，得到新的矩阵</span></span>
<span class="line"><span style="color:#e1e4e8;">        return result;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    // ...</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">Matrix m1;</span></span>
<span class="line"><span style="color:#e1e4e8;">Matrix m2;</span></span>
<span class="line"><span style="color:#e1e4e8;">Matrix m3 = m1 * m2; // 可以使用*号来将两个矩阵相乘</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>因为C++中的运算符重载功能比较强大，可以重载很多的运算符，从而提供类的使用更多的灵活性。举例来说，重载==和!=哪个更合适是需要视情况而定的。但需要注意的是，在使用重载运算符时，需要保证函数的行为符合对应运算符的语义，遵循C++中运算符的部分规则，避免造成误解和难以维护的代码。同时，如果重载运算符的使用不得当，也可能导致性能问题，需要谨慎使用。</p><h3 id="重载运算符的形式与规则" tabindex="-1">重载运算符的形式与规则 <a class="header-anchor" href="#重载运算符的形式与规则" aria-label="Permalink to &quot;重载运算符的形式与规则&quot;">​</a></h3><p>形式：<code>operator 类型名();</code></p><p>C++中允许通过重载运算符来自定义类的运算符的行为。在重载运算符时，需要注意以下规则：</p><ol><li><p>重载运算符是通过类的成员函数实现的。对于某些运算符（如赋值运算符=），也可以通过类的非成员函数实现。</p></li><li><p>重载运算符的函数名必须以operator关键字开始，后面紧跟要重载的运算符符号。例如，要重载加法运算符+，函数名应该为operator+()。</p></li><li><p>重载运算符可以是类的公有方法、私有方法或受保护方法（protected），但不能是静态方法（static）。</p></li><li><p>重载运算符可以为类定义新的语法形式，但需要遵循C++中运算符的部分规则。例如，赋值运算符=应该返回一个引用，缺省构造函数和析构函数没有参数等。</p></li><li><p>一些运算符（如逗号运算符,）只能通过成员函数重载，而另一些运算符（如类型转换操作符）只能通过成员函数或友元函数重载。</p></li></ol><p>下面是一个简单的例子，重载了加法运算符，比较运算符和输出运算符：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">class Integer {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Integer operator+(const Integer&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        Integer result;</span></span>
<span class="line"><span style="color:#e1e4e8;">        result.value = value + other.value;</span></span>
<span class="line"><span style="color:#e1e4e8;">        return result;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    bool operator&lt;(const Integer&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return value &lt; other.value;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Integer&amp; num) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        os &lt;&lt; num.value;</span></span>
<span class="line"><span style="color:#e1e4e8;">        return os;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    int value;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    Integer num1{10};</span></span>
<span class="line"><span style="color:#e1e4e8;">    Integer num2{20};</span></span>
<span class="line"><span style="color:#e1e4e8;">    Integer num3 = num1 + num2;</span></span>
<span class="line"><span style="color:#e1e4e8;">    std::cout &lt;&lt; (num1 &lt; num2) &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    std::cout &lt;&lt; num3 &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>在上述例子中，通过类的成员函数分别重载了加法运算符+和比较运算符&lt;，同时通过友元函数重载了输出运算符&lt;&lt;。这样，我们就可以使用+、&lt;和&lt;&lt;等符号，来直接操作Integer类的对象。</p><p>需要注意的是，重载运算符虽然很方便，但过多的使用运算符重载可能会影响代码的可读性和可维护性。在使用运算符重载时，需要评估是否有必要，以及重载后的行为是否与对应运算符的语义一致。</p><h3 id="重载运算符的运算" tabindex="-1">重载运算符的运算 <a class="header-anchor" href="#重载运算符的运算" aria-label="Permalink to &quot;重载运算符的运算&quot;">​</a></h3><p>C++中的运算符重载允许我们对自定义类型的对象进行像内置类型那样的运算。重载运算符的函数实现，就是为自定义类型对象进行相应的操作。</p><p>一般而言，重载运算符的运算规则与内置类型的运算符行为类似，例如：</p><ol><li>算术运算符（+、-、*、/等）可以对自定义类型的对象进行加、减、乘、除等算术运算；</li><li>关系运算符（==、!=、&lt;、&gt;、&lt;=、&gt;=等）可以进行对象之间的比较操作，返回bool类型；</li><li>赋值运算符（=）用于将一个对象的值赋给另一个对象，返回一个左值引用类型；</li><li>迭代器运算符（*、-&gt;、++、--等）可以对迭代器进行解引用、取值、自增、自减等操作；</li><li>位运算符（&amp;、|、^等）可以对对象的二进制数进行按位逻辑运算等。</li></ol><p>需要注意的是，在重载运算符时，需要尽量保证运算符的行为与内置类型的行为保持一致，减少使用者的学习成本和使用难度。同时，需要特别注意运算符重载的内存安全性和性能问题，例如对于+运算符以及其他需要分配内存的运算符，需要重载它们的数据类型的构造函数、析构函数和拷贝构造函数，避免内存泄漏和悬挂指针等问题，在使用时需要注意空间分配的效率。</p><p>下面是一个例子，展示如何重载运算符来实现自定义类型的加法和减法运算：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Complex {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex(double r = 0, double i = 0) : real(r), imag(i) {}</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex operator+(const Complex&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return Complex(real + other.real, imag + other.imag);</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex operator-(const Complex&amp; other) const {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return Complex(real - other.real, imag - other.imag);</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Complex&amp; num) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        os &lt;&lt; num.real &lt;&lt; &quot;+&quot; &lt;&lt; num.imag &lt;&lt; &quot;i&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">        return os;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">private:</span></span>
<span class="line"><span style="color:#e1e4e8;">    double real;</span></span>
<span class="line"><span style="color:#e1e4e8;">    double imag;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex c1{1, 2};</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex c2{3, 4};</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex c3 = c1 + c2;</span></span>
<span class="line"><span style="color:#e1e4e8;">    Complex c4 = c2 - c1;</span></span>
<span class="line"><span style="color:#e1e4e8;">    std::cout &lt;&lt; c3 &lt;&lt; std::endl; // 输出4+6i</span></span>
<span class="line"><span style="color:#e1e4e8;">    std::cout &lt;&lt; c4 &lt;&lt; std::endl; // 输出2+2i</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>在上述例子中，重载了加法运算和减法运算符+和-，并重载了输出运算符&lt;&lt;以便于输出实数和虚数运算结果。运行程序可以发现，成功实现了对复数的加减法运算。</p><p>综上所述，重载运算符可以使我们方便地对自定义类型的对象进行各种自定义的运算。当我们从自定义类型的角度考虑类的功能时，运算符重载有助于让类的使用更加自然和直观。</p><h2 id="多态" tabindex="-1">多态 <a class="header-anchor" href="#多态" aria-label="Permalink to &quot;多态&quot;">​</a></h2><p>多态性（polymorphism）是面向对象程序设计的一个重要特征，利用多态性可以设计和实现一个易于扩展的系统。在C++语言中，多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数，发出同样的消息被不同类型的对象接收时，导致完全不同的行为。这里所说的消息主要指类的成员函数的调用，而不同的行为是指不同的实现。多态性通过联编实现。联编是指一个计算机程序自身彼此关联的过程。按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。在C++中，根据联编的时刻不同，存在两种类型多态性，即函数重载和虚函数。</p><h3 id="虚函数" tabindex="-1">虚函数 <a class="header-anchor" href="#虚函数" aria-label="Permalink to &quot;虚函数&quot;">​</a></h3><p><strong>概述：</strong></p><p>在类的继承层次结构中，在不同的层次中可以出现名字、参数个数和类型都相同而功能不同的函数。编译器按照先自己后父类的顺序进行查找覆盖，如果子类有父类相同原型的成员函数时，要想调用父类的成员函数，需要对父类重新引用调用。虚函数则可以解决子类和父类相同原型成员函数的函数调用问题。虚函数允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。在基类中用virtual声明成员函数为虚函数，在派生类中重新定义此函数，改变该函数的功能。在C++语言中虚函数可以继承，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数，但如果派生类没有覆盖基类的虚函数，则调用时调用基类的函数定义。覆盖和重载的区别是，重载是同一层次函数名相同，覆盖是在继承层次中成员函数的函数原型完全相同。</p><p><strong>利用虚函数实现动态绑定：</strong></p><p>多态主要体现在虚函数上，只要有虚函数存在，对象类型就会在程序运行时动态绑定。动态绑定的实现方法是定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象，通过该指针变量调用此虚函数。</p><p>在C++中，虚函数实现了动态绑定的概念，使得程序具有更强的灵活性。在利用虚函数实现动态绑定时，需要注意以下几个方面：</p><ol><li><p>基类中的函数必须声明为虚函数。通常情况下，基类中声明为虚函数的函数都是希望在派生类中被重写的函数。如果一个函数没有在基类中声明为虚函数，那么它在派生类中的实现无论如何都不会覆盖基类的实现。</p></li><li><p>在派生类中，重新定义基类的虚函数时，需要使用override关键字。override关键字的作用是显式地告诉编译器，这个函数确实是想覆盖基类的虚函数。</p></li><li><p>通过父类指针或者引用调用虚函数时，实际上是调用了实际对象的函数。这是因为父类指针和引用是可以指向派生类对象的，而调用虚函数时会动态确定实际对象的类型，再用该类型的虚函数来代替基类的虚函数。</p></li><li><p>一个类的虚函数表只包含该类和其直接父类的虚函数，不包含其他间接父类中的虚函数。因此，多重继承、虚拟继承等情况下要注意虚函数的可见性。</p></li></ol><p>下面是一个简单的例子，说明如何利用虚函数实现动态绑定：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Base { // 基类</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void Function() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Base::Function()&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Derived : public Base { // 派生类</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    void Function() override {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Derived::Function()&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    Base* basePtr = new Base(); // 基类指针指向基类对象</span></span>
<span class="line"><span style="color:#e1e4e8;">    basePtr-&gt;Function(); // 调用基类的函数，输出 Base::Function()</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    Derived* derivedPtr = new Derived(); // 派生类指针指向派生类对象</span></span>
<span class="line"><span style="color:#e1e4e8;">    derivedPtr-&gt;Function(); // 调用派生类的函数，输出 Derived::Function()</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    Base* basePtr2 = new Derived(); // 基类指针指向派生类对象</span></span>
<span class="line"><span style="color:#e1e4e8;">    basePtr2-&gt;Function(); // 调用派生类的函数，输出 Derived::Function()</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    delete basePtr;</span></span>
<span class="line"><span style="color:#e1e4e8;">    delete derivedPtr;</span></span>
<span class="line"><span style="color:#e1e4e8;">    delete basePtr2;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>在上述例子中，定义了一个基类Base和一个派生类Derived，其中Base类中的Function函数被定义为虚函数。在main函数中，通过不同的指针调用了Base类和Derived类的Function函数，发现在基类指针指向派生类对象时，调用的是派生类中的Function函数，而不是基类中的Function函数。这就是虚函数实现的动态绑定的作用。</p><p>总之，虚函数是C++中面向对象编程的一个非常重要的特性，它可以使程序具有更强的灵活性，能够实现动态绑定、多态等高级特性。在实现时，需要注意虚函数的定义、重写、调用等问题，特别对于多重继承、虚拟继承等情况还需要注意虚函数表的可见性等问题。</p><p><strong>虚继承</strong></p><p>在C++中，虚继承是一种特殊的继承方式，它的作用是解决多重继承中的二义性问题。通常情况下，多重继承会带来二义性的问题，例如当一个类同时继承了两个基类，而这两个基类又继承自同一个基类时，就会导致出现歧义情况。</p><p>虚继承可以解决多重继承中的二义性问题，它的主要思想是让虚继承的子类共享同一个基类子对象（也称为虚基类，virtual base class）。如果一个类是通过虚继承得到的，那么它的虚基类的构造函数只会被调用一次，而不是多次。这样就可以避免虚基类子对象被多次构造、析构的问题，从而消除了二义性。</p><p>下面是一个简单的例子，说明如何使用虚继承来解决多重继承中的二义性问题：</p><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Animal {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Animal() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Animal constructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual ~Animal() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Animal destructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void eat() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Animal eat&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Flyable {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Flyable() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Flyable constructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual ~Flyable() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Flyable destructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void fly() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Flyable fly&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Bird : public virtual Animal, public virtual Flyable {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Bird() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Bird constructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual ~Bird() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Bird destructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void eat() override {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Bird eat&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void fly() override {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Bird fly&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class Penguin : public virtual Animal {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    Penguin() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Penguin constructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual ~Penguin() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Penguin destructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual void eat() override {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;Penguin eat&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">class PenguinBird : public Bird, public Penguin {</span></span>
<span class="line"><span style="color:#e1e4e8;">public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    PenguinBird() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;PenguinBird constructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    virtual ~PenguinBird() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        std::cout &lt;&lt; &quot;PenguinBird destructor&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">int main() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    PenguinBird pb;</span></span>
<span class="line"><span style="color:#e1e4e8;">    pb.eat();</span></span>
<span class="line"><span style="color:#e1e4e8;">    pb.fly();</span></span>
<span class="line"><span style="color:#e1e4e8;">    return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br></div></div><p>在上述例子中，定义了一个Animal类和一个Flyable类，它们都是需要虚继承的虚基类。然后定义了一个Bird类和一个Penguin类，它们都通过虚继承同时继承了Animal和Flyable类。在最后，定义了一个PenguinBird类，它同时继承了Bird类和Penguin类。</p><p>在main函数中，使用PenguinBird类创建了一个对象pb，并调用了它的eat和fly函数，发现它们分别由派生类Bird和Penguin分别实现，同时pb只共享了一个Animal和一个Flyable的虚基类子对象，避免了二义性的出现。</p><p>总之，虚继承是C++中多重继承的一种特殊方式，可以避免多重继承中常见的二义性问题。在使用虚继承时，需要注意虚基类的构造、析构、构造顺序等问题，以及虚继承带来的性能问题。</p><h2 id="抽象类" tabindex="-1">抽象类 <a class="header-anchor" href="#抽象类" aria-label="Permalink to &quot;抽象类&quot;">​</a></h2><p>包含有纯虚函数的类称为抽象类，一个抽象类至少具有一个纯虚函数。抽象类只能作为基类派生出的新的子类，而不能在程序中被实例化（即不能说明抽象类的对象），但是可以使用指向抽象类的指针。在开发程序过程中并不是所有代码都是由软件构造师自己写的，有时候需要调用库函数，有时候分给别人写。一名软件构造师可以通过纯虚函数建立接口，然后让程序员填写代码实现接口，而自己主要负责建立抽象类。</p><h3 id="纯虚函数" tabindex="-1">纯虚函数 <a class="header-anchor" href="#纯虚函数" aria-label="Permalink to &quot;纯虚函数&quot;">​</a></h3><p>纯虚函数（pure virtual function）是指被标明为不具体实现的虚成员函数，它不具备函数的功能。许多情况下，在基类中不能给虚函数一个有意义的定义，这时可以在基类中将它说明为纯虚函数，而其实现留给派生类去做。纯虚函数不能被直接调用，仅起到提供一个与派生类相一致的接口的作用。声明纯虚函数的形式如下：<code>virtual 类型 函数名(参数列表) = 0</code></p><p>纯虚函数不可以被继承。当基类是抽象类时，在派生类中必须给出基类中纯虚函数的定义，或在该类中再声明其为纯虚函数。只有在派生类中给出了基类中所有纯虚函数的实现时，该派生类才不再成为抽象类。</p><h1 id="高级" tabindex="-1">高级 <a class="header-anchor" href="#高级" aria-label="Permalink to &quot;高级&quot;">​</a></h1><h2 id="模板" tabindex="-1">模板 <a class="header-anchor" href="#模板" aria-label="Permalink to &quot;模板&quot;">​</a></h2><h2 id="标准模板库" tabindex="-1">标准模板库 <a class="header-anchor" href="#标准模板库" aria-label="Permalink to &quot;标准模板库&quot;">​</a></h2><h2 id="rtti与异常处理" tabindex="-1">RTTI与异常处理 <a class="header-anchor" href="#rtti与异常处理" aria-label="Permalink to &quot;RTTI与异常处理&quot;">​</a></h2><h2 id="程序调试" tabindex="-1">程序调试 <a class="header-anchor" href="#程序调试" aria-label="Permalink to &quot;程序调试&quot;">​</a></h2><h2 id="文件操作" tabindex="-1">文件操作 <a class="header-anchor" href="#文件操作" aria-label="Permalink to &quot;文件操作&quot;">​</a></h2><h2 id="网络通信" tabindex="-1">网络通信 <a class="header-anchor" href="#网络通信" aria-label="Permalink to &quot;网络通信&quot;">​</a></h2><h1 id="项目实战" tabindex="-1">项目实战 <a class="header-anchor" href="#项目实战" aria-label="Permalink to &quot;项目实战&quot;">​</a></h1><h2 id="人事考勤管理系统" tabindex="-1">人事考勤管理系统 <a class="header-anchor" href="#人事考勤管理系统" aria-label="Permalink to &quot;人事考勤管理系统&quot;">​</a></h2></div></div></main><footer class="VPDocFooter" data-v-c4b0d3cf data-v-face870a><!--[--><!--]--><div class="edit-info" data-v-face870a><div class="edit-link" data-v-face870a><a class="VPLink link edit-link-button" href="https://github.com/qiananran/tree/main/docs/scattered/dataStruct/cpp2.md" target="_blank" rel="noreferrer" data-v-face870a data-v-8f4dc553><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" aria-label="edit icon" data-v-face870a><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在 GitHub 上编辑此页面<!--]--><!----></a></div><div class="last-updated" data-v-face870a><p class="VPLastUpdated" data-v-face870a data-v-7b3ebfe1>最后一次更新于: <time datetime="2023-06-08T07:00:54.000Z" data-v-7b3ebfe1></time></p></div></div><div class="prev-next" data-v-face870a><div class="pager" data-v-face870a><a class="pager-link prev" href="/scattered/dataStruct/" data-v-face870a><span class="desc" data-v-face870a>上一篇</span><span class="title" data-v-face870a>简介</span></a></div><div class="has-prev pager" data-v-face870a><a class="pager-link next" href="/scattered/dataStruct/concept" data-v-face870a><span class="desc" data-v-face870a>下一篇</span><span class="title" data-v-face870a>数据结构基本概念</span></a></div></div></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-b2cf3e0b data-v-2f86ebd2><div class="container" data-v-2f86ebd2><p class="message" data-v-2f86ebd2>用心去梳理高质量的专业Ros内容，欢迎 <a target="_blank" style="color: var(--vp-c-brand)" href="https://github.com/qiananran">star ⭐</a> 让更多人发现</p><p class="copyright" data-v-2f86ebd2><a target="_blank" href="https://github.com/qiananran/blob/main/LICENSE">MIT License</a> | 版权所有 © 2022-2023 <a target="_blank" href="https://github.com/qiananran"> Qiananran contributors</a></p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"articles_main_index.md\":\"1cdc0e4d\",\"scattered_index.md\":\"18048d1e\",\"articles_main_read.md\":\"7b58fc0d\",\"ros_frame_support.md\":\"cbad269b\",\"project_index.md\":\"e1c86ccb\",\"ros_base_validation.md\":\"667cc579\",\"articles_index.md\":\"52a928ca\",\"download_software_teamcity.md\":\"2dde1115\",\"scattered_softtest_computercom.md\":\"0ac45f27\",\"download_index.md\":\"e0c5812c\",\"ros_frame_core.md\":\"469e9207\",\"matlab_index.md\":\"8dbab8e5\",\"ros_comm_index.md\":\"1db0eb6f\",\"index.md\":\"adae8bf4\",\"download_guide_index.md\":\"320b06d4\",\"scattered_softtest_index.md\":\"f8839dfa\",\"scattered_softtest_standardization.md\":\"4c4fdc00\",\"scattered_softtest_database.md\":\"d1303ffb\",\"ros_base_integration.md\":\"4eb72002\",\"scattered_softtest_multimedia.md\":\"ec3b8993\",\"scattered_softtest_operatingsystem.md\":\"8f580393\",\"scattered_datastruct_queue.md\":\"7bd8ee48\",\"ros_index.md\":\"85f34f75\",\"ros_base_experience.md\":\"3dac98e6\",\"scattered_deeplearn_overview.md\":\"449d03e4\",\"ros_comm_actioncomm.md\":\"261d8c17\",\"scattered_about_python_condacom.md\":\"70367156\",\"ros_frame_application.md\":\"2ee7e66d\",\"ros_comm_topiccomm.md\":\"fd28474f\",\"scattered_datastruct_linear.md\":\"bdd19473\",\"scattered_datastruct_index.md\":\"af23cee2\",\"ros_frame_filesystem.md\":\"f5160eaa\",\"ros_comm_servercomm.md\":\"00b6423e\",\"scattered_about_python_aboutpython.md\":\"2482d8ed\",\"scattered_datastruct_stack.md\":\"9f34e5e8\",\"ros_base_install.md\":\"33238898\",\"scattered_softtest_regulations.md\":\"42ba56e3\",\"scattered_datastruct_concept.md\":\"264a0ee7\",\"scattered_softtest_cpp.md\":\"959e5c4a\",\"ros_comm_paramcomm.md\":\"db4f0d91\",\"scattered_datastruct_cpp.md\":\"1892e5e2\",\"scattered_softtest_net.md\":\"c7041abe\",\"scattered_datastruct_cpp2.md\":\"8688c2c8\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"小锅盖儿\",\"description\":\"一站式的 Ros2 内容解释平台\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo4.png\",\"outline\":\"deep\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"returnToTopLabel\":\"返回顶部\",\"outlineTitle\":\"导航栏\",\"darkModeSwitchLabel\":\"外观\",\"sidebarMenuLabel\":\"归档\",\"editLink\":{\"pattern\":\"https://github.com/qiananran/tree/main/docs/:path\",\"text\":\"在 GitHub 上编辑此页面\"},\"lastUpdatedText\":\"最后一次更新于\",\"footer\":{\"message\":\"用心去梳理高质量的专业Ros内容，欢迎 <a target=\\\"_blank\\\" style=\\\"color: var(--vp-c-brand)\\\" href=\\\"https://github.com/qiananran\\\">star ⭐</a> 让更多人发现\",\"copyright\":\"<a target=\\\"_blank\\\" href=\\\"https://github.com/qiananran/blob/main/LICENSE\\\">MIT License</a> | 版权所有 © 2022-2023 <a target=\\\"_blank\\\" href=\\\"https://github.com/qiananran\\\"> Qiananran contributors</a>\"},\"nav\":[{\"text\":\"首页\",\"link\":\"/articles/\",\"activeMatch\":\"/articles/\"},{\"text\":\"专栏\",\"items\":[{\"text\":\"Ros2\",\"link\":\"/ros/\"},{\"text\":\"Matlab\",\"link\":\"/matlab/\"}]},{\"text\":\"杂记\",\"link\":\"/scattered/\"},{\"text\":\"项目\",\"activeMatch\":\"/project/\",\"link\":\"/project/\"},{\"text\":\"资源导航\",\"activeMatch\":\"/download/\",\"link\":\"/download/\"}],\"sidebar\":{\"/\":[{\"items\":[{\"text\":\"📖 阅读须知\",\"link\":\"/articles/\"}]},{\"text\":\"工具\",\"collapsed\":false,\"collapsible\":true,\"items\":[{\"text\":\"emoji-list\",\"link\":\"/tool/emoji-list\"}]},{\"text\":\"💡 备忘录\",\"collapsed\":false,\"collapsible\":true,\"items\":[{\"text\":\"Git 命令\",\"link\":\"/memo/git-command/\"}]}],\"/ros/\":[{\"items\":[{\"text\":\"📕 导读\",\"link\":\"/ros/\"}]},{\"text\":\"环境搭建\",\"collapsed\":true,\"items\":[{\"text\":\"ROS2 安装\",\"link\":\"/ros/base/install\"},{\"text\":\"ROS2 验证\",\"link\":\"/ros/base/validation\"},{\"text\":\"ROS2 集成开发环境\",\"link\":\"/ros/base/integration\"},{\"text\":\"ROS2 初体验\",\"link\":\"/ros/base/experience\"}]},{\"text\":\"体系框架\",\"collapsed\":true,\"items\":[{\"text\":\"文件系统\",\"link\":\"/ros/frame/fileSystem\"},{\"text\":\"核心模块\",\"link\":\"/ros/frame/core\"},{\"text\":\"技术支持\",\"link\":\"/ros/frame/support\"},{\"text\":\"应用方向\",\"link\":\"/ros/frame/application\"}]},{\"text\":\"通信服务\",\"collapsed\":true,\"items\":[{\"text\":\"简介\",\"link\":\"/ros/comm/\"},{\"text\":\"话题通信\",\"link\":\"/ros/comm/topiccomm\"},{\"text\":\"服务通信\",\"link\":\"/ros/comm/servercomm\"},{\"text\":\"动作通信\",\"link\":\"/ros/comm/actioncomm\"},{\"text\":\"参数通信\",\"link\":\"/ros/comm/paramcomm\"}]},{\"text\":\"Launch\",\"collapsed\":true,\"items\":[{\"text\":\"引言\",\"link\":\"\"}]},{\"text\":\"坐标变换\",\"collapsed\":true,\"items\":[{\"text\":\"引言\",\"link\":\"\"}]},{\"text\":\"可视化\",\"collapsed\":true,\"items\":[{\"text\":\"引言\",\"link\":\"\"}]}],\"/matlab/\":[{\"items\":[{\"text\":\"📕 导读\",\"link\":\"/matlab/\"}]},{\"text\":\"使用MATLAB\",\"collapsed\":true,\"items\":[]},{\"text\":\"使用Simulink\",\"collapsed\":true,\"items\":[]},{\"text\":\"工作流\",\"collapsed\":true,\"items\":[]},{\"text\":\"应用\",\"collapsible\":true,\"collapsed\":true,\"items\":[]}],\"/download/\":[{\"items\":[{\"text\":\"📕 导读\",\"link\":\"/download/\"}]},{\"text\":\"在线资源链接\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"工具链接\",\"link\":\"/download/guide/\"}]},{\"text\":\"Linux（Ubuntu）\",\"collapsible\":false,\"collapsed\":false,\"items\":[]}],\"/project/\":[{\"items\":[{\"text\":\"📕 导读\",\"link\":\"/project/\"}]},{\"text\":\"视觉生命\",\"collapsed\":true,\"items\":[{\"text\":\"初衷\",\"link\":\"\"},{\"text\":\"\",\"link\":\"\"}]},{\"text\":\"校园资讯\",\"collapsed\":true,\"items\":[{\"text\":\"初衷\",\"link\":\"\"},{\"text\":\"\",\"link\":\"\"}]},{\"text\":\"Ros 无人小车\",\"collapsed\":true,\"items\":[{\"text\":\"初衷\",\"link\":\"\"},{\"text\":\"\",\"link\":\"\"}]}],\"/scattered/\":[{\"items\":[{\"text\":\"📕 导读\",\"link\":\"/scattered/\"}]},{\"text\":\"数据结构与算法\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"简介\",\"link\":\"/scattered/dataStruct/\"},{\"text\":\"复习c++\",\"link\":\"/scattered/dataStruct/cpp2\"},{\"text\":\"数据结构基本概念\",\"link\":\"/scattered/dataStruct/concept\"},{\"text\":\"线性表\",\"link\":\"/scattered/dataStruct/Linear\"},{\"text\":\"数组和矩阵\",\"link\":\"/scattered/dataStruct/array\"},{\"text\":\"栈\",\"link\":\"/scattered/dataStruct/stack\"},{\"text\":\"队列\",\"link\":\"/scattered/dataStruct/queue\"},{\"text\":\"串\",\"link\":\"/scattered/dataStruct/string\"},{\"text\":\"数组和广义表\",\"link\":\"/scattered/dataStruct/\"},{\"text\":\"树和二叉树\",\"link\":\"/scattered/dataStruct/tree\"},{\"text\":\"图\",\"link\":\"/scattered/dataStruct/\"},{\"text\":\"查找\",\"link\":\"/scattered/dataStruct/\"},{\"text\":\"内部排序\",\"link\":\"\"},{\"text\":\"算法设计与分析\",\"link\":\"\"},{\"text\":\"贪婪算法\",\"link\":\"\"},{\"text\":\"分而治之\",\"link\":\"\"}]},{\"text\":\"软考中级软件设计师\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"简介\",\"link\":\"/scattered/softtest/\"},{\"text\":\"计算机组成与体系结构\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"操作系统基本原理\",\"link\":\"/scattered/softtest/operatingsystem\"},{\"text\":\"数据库系统\",\"link\":\"/scattered/softtest/database\"},{\"text\":\"计算机网络\",\"link\":\"/scattered/softtest/net\"},{\"text\":\"数据结构与算法\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"程序设计语言\",\"link\":\"/scattered/softtest/cpp\"},{\"text\":\"法律法规\",\"link\":\"/scattered/softtest/regulations\"},{\"text\":\"标准化\",\"link\":\"/scattered/softtest/standardization\"},{\"text\":\"多媒体基础\",\"link\":\"/scattered/softtest/multimedia\"},{\"text\":\"软件工程\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"面向对象\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"数据流程图\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"数据库设计\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"UML建模\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"数据结构与算法应用\",\"link\":\"/scattered/softtest/computercom\"},{\"text\":\"面向对象程序设计\",\"link\":\"/scattered/softtest/computercom\"}]},{\"text\":\"HCIA（华为数通初级认证）\",\"collapsed\":true,\"items\":[{\"text\":\"网络概述\",\"link\":\"/netexam/base/aboutIp\"},{\"text\":\"VRP基础\",\"link\":\"/netexam/base/aboutRoute\"},{\"text\":\"TCP/IP协议\",\"link\":\"/netexam/base/aboutSwitche\"},{\"text\":\"交换\",\"link\":\"/netexam/base/aboutVlan\"},{\"text\":\"交换机工作原理\",\"link\":\"/netexam/base/aboutStp\"},{\"text\":\"VLAN\",\"link\":\"/netexam/base/aboutPPP\"},{\"text\":\"GVRP\",\"link\":\"/netexam/base/aboutGarp\"},{\"text\":\"STP\",\"link\":\"/netexam/base/aboutSwitche\"},{\"text\":\"DHCP\",\"link\":\"/netexam/base/aboutVlan\"},{\"text\":\"ACL\",\"link\":\"/netexam/base/aboutStp\"},{\"text\":\"NAT\",\"link\":\"/netexam/base/aboutPPP\"},{\"text\":\"路由\",\"link\":\"/netexam/base/aboutGarp\"}]},{\"text\":\"HCIP（华为数通中级认证）\",\"collapsed\":true,\"items\":[{\"text\":\"认识网络设备\",\"link\":\"/netexam/base/aboutIp\"},{\"text\":\"IP路由基础\",\"link\":\"/netexam/base/aboutRoute\"},{\"text\":\"OSPF基础\",\"link\":\"/netexam/base/aboutSwitche\"},{\"text\":\"OSPF路由计算\",\"link\":\"/netexam/base/aboutVlan\"},{\"text\":\"OSPF特殊区域以其他特性\",\"link\":\"/netexam/base/aboutStp\"},{\"text\":\"IS-IS原理与配置\",\"link\":\"/netexam/base/aboutPPP\"},{\"text\":\"BGP基础\",\"link\":\"/netexam/base/aboutGarp\"},{\"text\":\"BGP路径属性与路由反射器\",\"link\":\"/netexam/base/aboutSwitche\"},{\"text\":\"BGP路由优选\",\"link\":\"/netexam/base/aboutVlan\"},{\"text\":\"BGP EVPN基础\",\"link\":\"/netexam/base/aboutStp\"},{\"text\":\"路由策略与路由控制\",\"link\":\"/netexam/base/aboutPPP\"},{\"text\":\"流量过滤与转发路径控制\",\"link\":\"/netexam/base/aboutGarp\"}]},{\"text\":\"深度学习（python）\",\"collapsed\":true,\"items\":[{\"text\":\"机器学习和深度学习综述\",\"link\":\"/scattered/deeplearn/Overview\"},{\"text\":\"使用Python和NumPy构建神经网络模型\",\"link\":\"/netexam/base/aboutRoute\"},{\"text\":\"NumPy介绍\",\"link\":\"/netexam/base/aboutSwitche\"},{\"text\":\"一个案例吃透深度学习（上）\",\"link\":\"/netexam/base/aboutVlan\"},{\"text\":\"一个案例吃透深度学习（中）\",\"link\":\"/netexam/base/aboutStp\"},{\"text\":\"一个案例吃透深度学习（下）\",\"link\":\"/netexam/base/aboutPPP\"},{\"text\":\"卷积神经网络基础\",\"link\":\"/netexam/base/aboutGarp\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/qianmunan\"}]},\"locales\":{\"root\":{\"label\":\"简体中文\",\"lang\":\"zh-CN\"}},\"scrollOffset\":90,\"cleanUrls\":true}")</script>
    
  </body>
</html>