import{_ as c}from"./chunks/Iframe.e3b129fc.js";import{_ as r,o as m,c as h,z as l,a,t as u,G as t,B as n,V as e,D as d}from"./chunks/framework.055571f3.js";const M=JSON.parse('{"title":"数据结构基本概念","description":"","frontmatter":{"title":"数据结构基本概念"},"headers":[],"relativePath":"scattered/dataStruct/concept.md","filePath":"scattered/dataStruct/concept.md","lastUpdated":1686207654000}'),p={name:"scattered/dataStruct/concept.md"},_={id:"frontmatter-title",tabindex:"-1"},b=l("img",{src:"https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305171011736.png",width:"46",height:"46",alt:"图片描述",style:{display:"inline","margin-bottom":"-6px"}},null,-1),f=l("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}} <img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305171011736.png" width="46" height="46" alt="图片描述" style="display:inline; margin-bottom: -6px"/>"'},"​",-1),g=e('<div class="tip custom-block"><p class="custom-block-title">TIP</p><p>数据结构主要研究4方面的问题：</p><ol><li>数据的逻辑结构：即数据之间的逻辑关系</li><li>数据的物理结构：即数据在计算机内的存储方式</li><li>对数据的加工，即基于某种存储方式的运行算法</li><li>算法的分析：即评价算法的优劣</li></ol></div><h2 id="开题之前" tabindex="-1">开题之前 <a class="header-anchor" href="#开题之前" aria-label="Permalink to &quot;开题之前&quot;">​</a></h2><blockquote><p>在我们正式学习数据结构与算法之前，我们先聊两点</p><ul><li>什么是数据结构</li><li>我们学他有什么意义</li></ul></blockquote><div class="tip custom-block"><p class="custom-block-title">1. 什么是数据结构</p><p>就是将我们的数据以某种结构归纳在一起，它的主体是数据，而实现方式是结构。正所谓没有数据何谈结构呢?😄 虽然我们说数据是主体，但数据结构这门课要学的而是它的结构。为什么在这里抛弃了主体，而去实现结构呢？因为在数据结构与算法中数据其实不重要，而重要的是我们如何将一些数据规整起来。这个动作就是我们要学的结构二字。</p></div><div class="tip custom-block"><p class="custom-block-title">我们学它有什么意义呢？</p><p>其实在学习这门课的时候，很难感受到它的真实意义。出现这种状况的原因是我们缺少它的主体，也就是数据。因为在这里面的数据99％的都是我们自己虚构出来的。可以说他没有什么实际含义。但当我们学会了这门学时没意义的课之后，并且运用到日常开发之中，你就会体会到它的意义是什么了。他是一个先苦后甜的过程。</p><p>意义：让我们的数据更加规范，提高代码效率。丰富自己的编程思维</p></div><div class="tip custom-block"><p class="custom-block-title">3. 在说一下算法</p><p>简单点来说：它就是解决某个问题的某个程序，就是按照一定的逻辑，将输入的数据，转换成结果并输出出来。</p></div><h2 id="正式开始" tabindex="-1">正式开始 <a class="header-anchor" href="#正式开始" aria-label="Permalink to &quot;正式开始&quot;">​</a></h2>',7),k={class:"info custom-block"},x=l("p",{class:"custom-block-title"},"先听个音乐🎵",-1),y=e('<h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p>🤠学习一门新的东西，应该先了解一下，它的概念。何为概念：就是用最少的语言，把一件事情讲清楚。所以应该，先高明白在数据结构中包含的一些基本概念。</p><h3 id="数据与数据元素" tabindex="-1">数据与数据元素 <a class="header-anchor" href="#数据与数据元素" aria-label="Permalink to &quot;数据与数据元素&quot;">​</a></h3><ul><li>数据：是对客观事物的符号表示，它能被计算机识别、存储和加工处理。</li><li>数据元素(Data Element)：数据的基本单位，有时也成为元素、结点、顶点、记录。</li><li>数据项(): 最小的标识单位，又是也称为字段、域或属性。</li><li>数据结构(): 数据元素之间的相互关系，即数据的组织形式 <ul><li>元素之间的逻辑关系，也称为逻辑结构。可以独立于计算机。</li><li>数据元素及逻辑关系在计算机存储器内的表示方式，称为数据的存储结构。它是逻辑结构在计算机存储器中的映射，必须依赖与计算机。</li><li>数据运算：对数据施加的操作。</li><li>注意：云端的定义直接依赖于逻辑结构，但运算的实现必须依赖于存储结构。</li></ul></li></ul><h3 id="数据的逻辑结构" tabindex="-1">数据的逻辑结构 <a class="header-anchor" href="#数据的逻辑结构" aria-label="Permalink to &quot;数据的逻辑结构&quot;">​</a></h3>',5),T=l("ol",null,[l("li",null,"集合：任何两个元素之间都没有逻辑关系，每个元素都是独立的"),l("li",null,"线性结构：结构中的元素之间存在一对一的关系。也就是说最前面的一个元素，后面有且只有一个元素。而最后面一个元素的前面，有且仅有一个元素。"),l("li",null,"树形结构：结构中的数据元素之间存在一对多的关系。可以想象为一棵倒立的树木。"),l("li",null,"图状结构：结构中的数据元素之间存在多对多的关系。")],-1),P=l("p",null,"总结：通常将集合，树形结构，图状结构归纳为非线性结构。因此数据的逻辑结构分为两大类，线性结构和非线性结构",-1),q=l("h3",{id:"数据的存储结构",tabindex:"-1"},[a("数据的存储结构 "),l("a",{class:"header-anchor",href:"#数据的存储结构","aria-label":'Permalink to "数据的存储结构"'},"​")],-1),S=l("ol",null,[l("li",null,"顺序存储：将数据元素依次存储于一组地址连续的存储单元中，元素间的逻辑关系由存储单元的位置直接体现，由此得出存储表示称为顺序存储结构"),l("li",null,"链式存储：将数据元素存储在一组任意的存储单元中，用附加的指针域表示元素之间的逻辑关系"),l("li",null,"索引存储：特点在存储数据元素的同时，还可以建立附加的索引表。索引表中的每一项称为索引项，索引项的格式为（关键字，地址），关键字是指能位移标识数据元素在索引表中均有一个索引项。"),l("li",null,"散列存储：用一个事先设计好的函数计算出该数据元素的存储地址，然后把它存入该地址中。")],-1),O=l("h3",{id:"数据运算",tabindex:"-1"},[a("数据运算 "),l("a",{class:"header-anchor",href:"#数据运算","aria-label":'Permalink to "数据运算"'},"​")],-1),v=l("h3",{id:"数据类型",tabindex:"-1"},[a("数据类型 "),l("a",{class:"header-anchor",href:"#数据类型","aria-label":'Permalink to "数据类型"'},"​")],-1),A=l("ol",null,[l("li",null,"原子类型：其值不可分解。C++中的基本数据类型（整型、字符型、枚举类型）、指针类型和空类型"),l("li",null,"结构类型：其值可分解成若干成分。比如C语言中的结构体")],-1),V=l("h3",{id:"抽象数据类型",tabindex:"-1"},[a("抽象数据类型 "),l("a",{class:"header-anchor",href:"#抽象数据类型","aria-label":'Permalink to "抽象数据类型"'},"​")],-1),C=l("p",null,"抽象数据类型（Abstract Data Type）：一个数学模型，以及定义在该模型上的一组操作。就是一个抽象的概念，是以数学模型为主体的，不依赖于内部的变化。",-1),D=e('<h2 id="算法分析" tabindex="-1">算法分析 <a class="header-anchor" href="#算法分析" aria-label="Permalink to &quot;算法分析&quot;">​</a></h2><h3 id="算法的定义和描述" tabindex="-1">算法的定义和描述 <a class="header-anchor" href="#算法的定义和描述" aria-label="Permalink to &quot;算法的定义和描述&quot;">​</a></h3><p>算法（Algorithm）：简单来说是对特定问题求解步骤的描述，是指令的有限序列。<br></p><p>算法的五大特性：</p><ol><li>有穷性：一个算法对于任何合法的输入必须在执行有限步骤后结束，且每一个步骤需要在有限的时间内完成</li><li>确定性：算法的每条指令必须有确切含义，在任何条件下，算法只有唯一的一条执行路径，对相同的输入只能有相同的输出结构（其实并不然，只是就目前而言，我们人为规定是这样的。因为在大语言模型中，在有相同的输入中，不一定有相同的输出。）</li><li>可执行性：算法是可行的，算法中描述的操作均可通过已经实现的基本运算的有限次执行来实现。</li><li>输入：一个算法有零个或多个输入，这些输入取自算法加工对象的集合。</li><li>输出：一个算法有一个或多个输出，这些输出应是算法对输入加工后合乎逻辑的结果。</li></ol><h3 id="算法评价" tabindex="-1">算法评价 <a class="header-anchor" href="#算法评价" aria-label="Permalink to &quot;算法评价&quot;">​</a></h3><ol><li>正确性：算法的正确性有四个层次的要求 <ol><li>算法没有语法错误</li><li>算法对于几组输入数据能够得出满足规格说明要求的结果</li><li>算法对于惊醒选择的苛刻并带有刁难型的机组输入数据能够得出满足规格说明要求的结果。</li><li>算法对于一切合法的输入数据都能得出满足规格说明要求的结果。</li></ol></li><li>可读性：无论任何算法，都应便于人们阅读，和理解</li><li>健壮性：当输入合法的数据有相应的反馈，当有不合法的输入，应该有相应的反馈</li><li>时空效率：要求算法在尽可能短的时间内完成运算。</li></ol><h3 id="算法性能分析和度量" tabindex="-1">算法性能分析和度量 <a class="header-anchor" href="#算法性能分析和度量" aria-label="Permalink to &quot;算法性能分析和度量&quot;">​</a></h3><p>时间复杂度和空间复杂度是算法分析中常用的两个指标，它们用于衡量不同算法在执行时所需的时间和空间资源。</p><ol><li>时间复杂度</li></ol>',10),I=l("p",null,[a("时间复杂度是指算法的执行时间随着输入规模增加而增长的速度。通常用大O符号来表示，即"),l("p",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",null,[l("semantics",null,[l("mrow",null,[l("mi",null,"T"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,"="),l("mi",null,"O"),l("mo",null,"("),l("mi",null,"f"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,")")]),l("annotation",{encoding:"application/x-tex"},"T(n)=O(f(n))")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"strut",style:{height:"0.75em"}}),l("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"base textstyle uncramped"},[l("span",{class:"mord mathit",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mrel"},"="),l("span",{class:"mord mathit",style:{"margin-right":"0.02778em"}},"O"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mclose"},")")])])])]),a("，其中T(n)表示算法执行的时间，f(n)表示问题规模n的函数。一般情况下，我们会关注最坏情况下的时间复杂度，因为最坏情况下是算法执行最慢的情况，也是我们需要关注的。")],-1),N=l("p",null,"常见的时间复杂度有：",-1),$=l("ul",null,[l("li",null,"O(1)：常数时间复杂度，无论算法输入规模如何，算法执行的时间都保持不变。"),l("li",null,"O(log n)：对数时间复杂度，通常用于二分查找等问题，时间复杂度相对较低。"),l("li",null,"O(n)：线性时间复杂度，算法执行时间与输入规模呈线性关系。"),l("li",null,"O(n log n)：常见的排序算法如快速排序、归并排序等的时间复杂度。"),l("li",null,"O(n^2)：平方时间复杂度，通常用于简单排序算法如冒泡排序、插入排序等。"),l("li",null,"O(2^n)：指数时间复杂度，当算法要处理的数据集合中的数据元素个数非常大时，通常会出现这种复杂度。")],-1),w=l("ol",{start:"2"},[l("li",null,"空间复杂度")],-1),E=l("p",null,[a("空间复杂度是指算法所需内存空间随着输入规模增加而增长的速度。通常用大O符号来表示，即"),l("p",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",null,[l("semantics",null,[l("mrow",null,[l("mi",null,"S"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,"="),l("mi",null,"O"),l("mo",null,"("),l("mi",null,"f"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,")")]),l("annotation",{encoding:"application/x-tex"},"S(n)=O(f(n))")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"strut",style:{height:"0.75em"}}),l("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"base textstyle uncramped"},[l("span",{class:"mord mathit",style:{"margin-right":"0.05764em"}},"S"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mrel"},"="),l("span",{class:"mord mathit",style:{"margin-right":"0.02778em"}},"O"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mclose"},")")])])])]),a("，其中S(n)表示算法占用的空间大小，f(n)表示问题规模n的函数。和时间复杂度类似，我们关注的也是最坏情况下的空间复杂度。")],-1),B=l("p",null,"常见的空间复杂度有：",-1),z=l("ul",null,[l("li",null,"O(1)：常数空间复杂度，算法所需空间为一个固定大小。"),l("li",null,"O(n)：线性空间复杂度，算法所需的空间与问题规模呈线性关系。"),l("li",null,"O(n^2)：平方空间复杂度，通常出现在需要使用二维数组或矩阵的算法中。")],-1),R=l("p",null,"总之，时间复杂度和空间复杂度都是衡量算法效率和优化的重要标准，开发者需要考虑算法的性质，根据实际场景来选择最合适的算法以提高执行效率和节省资源消耗。",-1);function G(i,J,U,j,F,H){const o=c,s=d("font");return m(),h("div",null,[l("h1",_,[a(u(i.$frontmatter.title)+" ",1),b,a(),f]),g,l("div",k,[x,t(o,{mylink:"//music.163.com/outchain/player?type=2&id=1306923998&auto=1&height=66"})]),y,l("p",null,[a("数据的逻辑结构是从逻辑关系上描述数据，不涉及数据在计算机中的存储，"),t(s,{color:"red"},{default:n(()=>[a("是独立于计算机的")]),_:1}),a("。数据的逻辑结构是编程人员根据具体问题抽象出来的数学模型。其中在逻辑结构中有四种形式的逻辑关系。")]),T,P,q,l("p",null,[a("数据的存储结构是指数据在计算机内的表示方法，是逻辑结构在计算机中的具体实现。所以存储结构包含两个方面"),t(s,{color:"blue"},{default:n(()=>[a("数据元素的本身")]),_:1}),a("和"),t(s,{color:"blue"},{default:n(()=>[a("数据元素间逻辑的关系")]),_:1}),a("。")]),S,O,l("p",null,[a("数据运算是对数据施加的操作。每种逻辑结构都有一个基本运算的集合。可以简单理解为，对数据的增删改查。"),t(s,{color:"red"},{default:n(()=>[a("运算在逻辑结构上定义，在存储结构上实现")]),_:1}),a("。")]),v,A,V,C,l("p",null,[a("其构成为"),t(s,{color:"red"},{default:n(()=>[a("元素、关系、操作")]),_:1}),a("三种要素构成。")]),D,I,N,$,w,E,B,z,R])}const Q=r(p,[["render",G]]);export{M as __pageData,Q as default};
