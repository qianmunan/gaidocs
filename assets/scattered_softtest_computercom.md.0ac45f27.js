import{_ as r,o as p,c,z as a,a as l,t as i,G as e,B as n,V as o,D as d}from"./chunks/framework.055571f3.js";const T=JSON.parse('{"title":"计算机组成与体系结构","description":"","frontmatter":{"title":"计算机组成与体系结构"},"headers":[],"relativePath":"scattered/softtest/computercom.md","filePath":"scattered/softtest/computercom.md","lastUpdated":1683208042000}'),h={name:"scattered/softtest/computercom.md"},u={id:"frontmatter-title",tabindex:"-1"},C=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),_=o('<h2 id="数据的表示" tabindex="-1">数据的表示 <a class="header-anchor" href="#数据的表示" aria-label="Permalink to &quot;数据的表示&quot;">​</a></h2><h2 id="flynn" tabindex="-1">Flynn <a class="header-anchor" href="#flynn" aria-label="Permalink to &quot;Flynn&quot;">​</a></h2><p>在计算机科学中，Flynn是用于描述并行计算的一种分类系统，以计算机科学家Michael J. Flynn的名字命名。这个分类系统基于两个因素：指令流和数据流。指令流指的是处理器处理指令的方式，数据流指的是处理器在执行指令时访问数据的方式。</p><p>根据指令流和数据流的不同，Flynn系统将并行计算分为四个不同的类别：</p><ol><li><p>单指令流单数据流 (SISD)：这是传统的计算机结构，其中有一个处理器执行一条指令并处理一条数据。它不能并行处理多个指令或数据流。</p></li><li><p>单指令流多数据流 (SIMD)：这种结构有一个指令流但可以同时处理多个数据流。这种结构通常用于向量计算和图形处理单元。</p></li><li><p>多指令流单数据流 (MISD)：这种结构有多个指令流但只能处理一个数据流。这种结构通常用于需要高度冗余或错误检测的应用程序。</p></li><li><p>多指令流多数据流 (MIMD)：这种结构有多个指令流和多个数据流。这是最常见的并行计算结构，通常用于并行处理程序和集群计算。</p></li></ol><p>Flynn分类系统在并行计算领域中被广泛使用，帮助人们更好地理解并行计算系统的工作原理和性能。 写一个关于Flynn的博客</p><h2 id="clsc与risc" tabindex="-1">CLSC与RISC <a class="header-anchor" href="#clsc与risc" aria-label="Permalink to &quot;CLSC与RISC&quot;">​</a></h2><p>随着计算机发展的历程，指令集架构（ISA）逐步演变为两种主流类型：复杂指令集计算机（CISC）与精简指令集计算机（RISC）。下面以这两种指令集架构为中心，为大家介绍这两种架构，并探讨它们的优缺点。 CISC架构是指令集架构中早期的一种，它采用更为复杂的指令集和复杂的硬件来执行更为复杂的任务。此架构使用大量的指令，其每条指令可执行多项操作，例如内存加载、运算、移位、分支操作等。CISC指令集还提供了一些高级功能，如乘除操作、浮点运算等。常见的CISC架构包括x86、VAX和IBM的System/360等。</p><h3 id="cisc-复杂指令集计算机" tabindex="-1">CISC(复杂指令集计算机) <a class="header-anchor" href="#cisc-复杂指令集计算机" aria-label="Permalink to &quot;CISC(复杂指令集计算机)&quot;">​</a></h3>',9),E=a("ol",null,[a("li",null,"执行效率高：一条CISC指令可以执行多个操作，因此单条指令可以完成大量的工作。"),a("li",null,"易于编写和优化程序：使用高级指令可以更快地编写和优化程序，因为程序员可以利用更多的指令功能来执行更多的操作。"),a("li",null,[l("更接近人的思维方式：CISC指令的复杂度更接近人类思维方式，减少了编写程序的复杂性，也使得代码更易于理解。"),a("br")])],-1),y=a("ol",null,[a("li",null,"硬件设计复杂：由于指令集复杂，CISC架构需要更复杂的硬件实现多条指令并行。这增加了硬件设计的难度和计算机的成本。"),a("li",null,"难于扩展：CISC架构的指令集非常庞大，难以扩展，很难添加新功能。这使得CISC架构的更新和改进变得困难，难以满足新应用的需求。")],-1),b=a("h3",{id:"risc-简化指令集计算机",tabindex:"-1"},[l("RISC(简化指令集计算机) "),a("a",{class:"header-anchor",href:"#risc-简化指令集计算机","aria-label":'Permalink to "RISC(简化指令集计算机)"'},"​")],-1),S=a("p",null,"RISC架构（简化指令集计算机）采用更少的指令集，每条指令的操作较单一，且执行指令的硬件更加简单。常见的RISC架构包括ARMv8、SPARC、MIPS等。",-1),m=a("ol",null,[a("li",null,"处理器设计简单：由于指令集简单，RISC架构处理器所需的硬件更少，设计更为简化。"),a("li",null,"易于扩展：由于指令集简单，RISC架构可以很容易地添加新功能，从而满足新应用的需求。"),a("li",null,"更易于实现流水线：由于指令集相对简单，RISC架构更易于实现流水线。")],-1),I=o(`<ol><li>不够灵活：独立的RISC指令需要更多的内存访问次数，从而增加了存储器带宽的使用，通常需要更多的载入和存储操作。</li><li>执行效率可能降低：需要多条指令才能实现一个复杂的操作，因此单条指令的执行效率可能比CISC低。</li></ol><h2 id="流水线技术" tabindex="-1">流水线技术 <a class="header-anchor" href="#流水线技术" aria-label="Permalink to &quot;流水线技术&quot;">​</a></h2><p>计算机中的流水线技术是一种将指令执行分为多个阶段的方法，以提高计算机的执行效率。流水线技术采用分段执行的方式，将计算机执行指令的不同任务分为多个部分，可以同时处理多个指令的不同部分。</p><p>一个完整的指令执行需要经过多个阶段，如<code>取指、译码、执行、访存和写回</code>，这些阶段可以称为指令执行过程的5个阶段。在流水线技术中，计算机可以将某一条指令在执行一个阶段的同时执行其他指令的其他阶段，这样可以实现多条指令之间相互独立的执行，从而<code>提高了计算机的效率和吞吐量</code>。</p><p>流水线技术的优点主要有以下几点：</p><ol><li>提高CPU的执行效率：由于流水线技术可以同时处理多个指令的不同阶段，因此可以减少计算机执行指令的时间，提高CPU的执行效率。</li><li>最大程度利用CPU的硬件资源：流水线技术可以同时利用CPU的不同功能单元，最大化地利用了计算机的硬件资源。</li><li>提供更高的指令吞吐量：由于可以同时执行多条指令的不同阶段，所以可以提供更高的指令吞吐量，从而提高了计算机的性能。</li></ol><p>但是，流水线技术也存在一些缺点：</p><ol><li>硬件延迟：流水线技术存在一个硬件延迟问题，即每条指令的执行时间不同。这就意味着，某些指令的执行可能需要等待前面指令的执行完成，从而影响整个计算机的效率。</li><li>数据冲突：由于流水线技术可以同时处理多个指令，因此可能存在数据冲突的问题，例如写后读等操作可能会导致操作间的冲突，这会影响计算机的性能。</li><li>为了解决这些缺点，多种技术被提出，如分支预测、指令重排、数据前推等。这些技术可以帮助解决流水线技术中出现的问题，从而更好地发挥出流水线技术的优点。</li></ol><p>流水线技术是计算机系统性能提升的关键因素之一，广泛应用于各种计算机硬件的设计中。随着计算机技术的进步，流水线技术也在不断发展和完善，将在未来的计算机系统中扮演着更为重要的角色。</p><div class="language-cpp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">流水线周期：为执行时间最长的一段</span></span>
<span class="line"><span style="color:#E1E4E8;">流水线计算公式：</span></span>
<span class="line"><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">条指令执行时间 </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> （指令条数</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">）</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> 流水线周期</span></span>
<span class="line"><span style="color:#E1E4E8;">①理论公式： （t1</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">t2</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">...</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">tk）</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> (n</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Δt</span></span>
<span class="line"><span style="color:#E1E4E8;">②实践公式：（k </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">）</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> Δt。k的意思是“取指，分析，执行”三部分组成</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="吞吐率计算" tabindex="-1">吞吐率计算 <a class="header-anchor" href="#吞吐率计算" aria-label="Permalink to &quot;吞吐率计算&quot;">​</a></h3><p>流水线的吞吐率（）是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的最基本的公式为 TP = 指令条数/流水线执行时间</p><h3 id="加速比计算" tabindex="-1">加速比计算 <a class="header-anchor" href="#加速比计算" aria-label="Permalink to &quot;加速比计算&quot;">​</a></h3><p>完成同样一批任务，不使用流水线所用的时间与施一公流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本公式为 s = 不使用流水线执行时间/使用流水线执行时间</p><h2 id="存储系统" tabindex="-1">存储系统 <a class="header-anchor" href="#存储系统" aria-label="Permalink to &quot;存储系统&quot;">​</a></h2><h2 id="总线系统" tabindex="-1">总线系统 <a class="header-anchor" href="#总线系统" aria-label="Permalink to &quot;总线系统&quot;">​</a></h2><h2 id="系统可靠性分析" tabindex="-1">系统可靠性分析 <a class="header-anchor" href="#系统可靠性分析" aria-label="Permalink to &quot;系统可靠性分析&quot;">​</a></h2><h2 id="校验码" tabindex="-1">校验码 <a class="header-anchor" href="#校验码" aria-label="Permalink to &quot;校验码&quot;">​</a></h2><p>CRC与海明校验码</p>`,19);function f(t,F,P,q,k,x){const s=d("font");return p(),c("div",null,[a("h1",u,[l(i(t.$frontmatter.title)+" ",1),C]),_,e(s,{color:"blue"},{default:n(()=>[l("CISC架构有以下优点：")]),_:1}),E,e(s,{color:"blue"},{default:n(()=>[l("但是，CISC架构也存在以下缺点：")]),_:1}),y,b,S,e(s,{color:"blue"},{default:n(()=>[l("RISC架构有以下优点：")]),_:1}),m,e(s,{color:"blue"},{default:n(()=>[l("但是，RISC架构也存在以下缺点：")]),_:1}),I])}const A=r(h,[["render",f]]);export{T as __pageData,A as default};
