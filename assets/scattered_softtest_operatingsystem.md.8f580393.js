import{_ as l,o as r,c as h,z as e,a,t as n,G as s,B as d,V as t,D as c}from"./chunks/framework.055571f3.js";const N=JSON.parse('{"title":"数据库系统","description":"","frontmatter":{"title":"数据库系统"},"headers":[],"relativePath":"scattered/softtest/operatingsystem.md","filePath":"scattered/softtest/operatingsystem.md","lastUpdated":1686207654000}'),p={name:"scattered/softtest/operatingsystem.md"},u={id:"frontmatter-title",tabindex:"-1"},m=e("img",{src:"https://gaidocs.oss-cn-hangzhou.aliyuncs.com/emoji/202305111530641.png",width:"46",height:"46",alt:"图片描述",style:{display:"inline","margin-bottom":"-10px"}},null,-1),_=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}} <img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/emoji/202305111530641.png" width="46" height="46" alt="图片描述" style="display:inline; margin-bottom: -10px"/>"'},"​",-1),b=t('<h2 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to &quot;进程管理&quot;">​</a></h2><p>进程（Process）是操作系统中的一个基本概念，它可以看做是一个正在执行的程序实例。进程管理是操作系统中非常重要的一环，其中主要包括进程的创建、终止、调度、同步和通信等方面。</p><p>具体来说，进程管理包括以下几个方面：</p><ol><li><p>进程的创建：当用户启动一个应用程序时，系统会为该应用程序创建一个新进程并分配相应资源。进程创建通常涉及到创建 PCB（Process Control Block）块、内存空间分配、权限设置等流程。</p></li><li><p>进程的终止：当进程完成了它的任务或者发生严重错误时，需要将其优雅地结束。操作系统会回收已分配给该进程的各种资源，销毁该进程的 PCB。</p></li><li><p>进程的调度：由于计算机是多任务操作的，多个进程可能同时存在于内存中。操作系统需要合理安排 CPU 时间片、进程优先级、队列等信息，决定哪些进程最先得到 CPU 的使用权执行。</p></li><li><p>进程的同步和通信：不同的进程之间需要进行信息交互和数据共享。这需要操作系统提供进程间的同步和通信机制，如管道、消息队列、信号量等。</p></li></ol><h3 id="进程的状态" tabindex="-1">进程的状态 <a class="header-anchor" href="#进程的状态" aria-label="Permalink to &quot;进程的状态&quot;">​</a></h3><p>在操作系统中，进程可以处于以下几种不同的状态：</p><ol><li><p>创建态（NEW）：当系统创建一个新的进程时，它位于创建态。此时正在为该进程分配内存空间和其他资源。</p></li><li><p>就绪态（READY）：当进程已经获取了所有必要的资源，并等待能够被 CPU 执行时，该进程处于就绪态。操作系统会将就绪态的进程放入就绪队列中，等待调度执行。</p></li><li><p>运行态（RUNNING）：当进程获得 CPU 的使用权并正在执行指令时，该进程处于运行态。</p></li><li><p>阻塞态（BLOCKED）：当进程需要等待某一事件发生而暂时不能执行时，它处于阻塞态。例如，当进程请求某个资源时，如果该资源已经被其他进程占用，在这段时间内该进程可能被阻塞。</p></li><li><p>终止态（TERMINATED）：当进程完成了它的任务或者因为某种原因出现异常而被强制结束时，该进程位于终止态。在终止之前，操作系统通常会回收该进程所占用的各种资源。</p></li></ol><p>上述进程状态之间的转换称为进程状态转换，主要有以下几种方式：</p><ol><li><p>从创建态到就绪态：当操作系统为进程分配好资源后，该进程处于创建状态，此时操作系统将它放入就绪队列中，等待被调度。</p></li><li><p>从就绪态到运行态：当操作系统选定了一个就绪进程并为其分配 CPU 时间片时，该进程处于就绪状态，然后进入运行状态。</p></li><li><p>从运行态到就绪态：当进程用完一次时间片或者等待某种事件（如 IO 操作）时，会释放 CPU 的使用权，进入就绪态，然后重新加入就绪队列等待下次调度。</p></li><li><p>从运行态到阻塞态：当进程需要等待某些事件（如读取磁盘数据）时，会主动让出 CPU 的使用权，并进入阻塞态。在事件完成之前，该进程将一直是阻塞状态。</p></li><li><p>从阻塞态到就绪态：当一个被阻塞的进程等待的事件完成时，它将离开阻塞态，并被置为就绪态，以便重新进入就绪队列等待下一次调度。</p></li><li><p>从运行态到终止态：当进程执行完成并成功结束时，该进程将置为终止态；当进程出现异常错误或强制结束时，也将转入终止态。</p></li></ol><p><img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305111537205.png" alt=""></p><h3 id="前驱图" tabindex="-1">前驱图 <a class="header-anchor" href="#前驱图" aria-label="Permalink to &quot;前驱图&quot;">​</a></h3>',11),P=t('<p>在进程前驱图中，如果一个进程的输出作为另一个进程的输入，那么这两个进程之间就存在一个依赖关系。通过绘制这些依赖关系，我们可以清晰地了解每个进程之间的相互关系，并且可以确定执行每个进程所需要的先决条件。</p><p>通常情况下，进程前驱图可以帮助我们进行进程调度和优化任务的执行流程，从而提高系统的性能和可靠性。例如，在复杂的工业自动化场景中，我们可以使用进程前驱图来规划整个生产线上的各个任务之间的依赖关系，以优化生产效率和降低成本。</p><h3 id="进程的同步与互斥" tabindex="-1">进程的同步与互斥 <a class="header-anchor" href="#进程的同步与互斥" aria-label="Permalink to &quot;进程的同步与互斥&quot;">​</a></h3><h3 id="pv操作" tabindex="-1">PV操作 <a class="header-anchor" href="#pv操作" aria-label="Permalink to &quot;PV操作&quot;">​</a></h3><h3 id="死锁问题" tabindex="-1">死锁问题 <a class="header-anchor" href="#死锁问题" aria-label="Permalink to &quot;死锁问题&quot;">​</a></h3><h2 id="存储管理" tabindex="-1">存储管理 <a class="header-anchor" href="#存储管理" aria-label="Permalink to &quot;存储管理&quot;">​</a></h2><h3 id="分区存储组织" tabindex="-1">分区存储组织 <a class="header-anchor" href="#分区存储组织" aria-label="Permalink to &quot;分区存储组织&quot;">​</a></h3><h3 id="页式存储组织" tabindex="-1">页式存储组织 <a class="header-anchor" href="#页式存储组织" aria-label="Permalink to &quot;页式存储组织&quot;">​</a></h3><h3 id="段式存储组织" tabindex="-1">段式存储组织 <a class="header-anchor" href="#段式存储组织" aria-label="Permalink to &quot;段式存储组织&quot;">​</a></h3><h3 id="段页式存储组织" tabindex="-1">段页式存储组织 <a class="header-anchor" href="#段页式存储组织" aria-label="Permalink to &quot;段页式存储组织&quot;">​</a></h3><h3 id="快表" tabindex="-1">快表 <a class="header-anchor" href="#快表" aria-label="Permalink to &quot;快表&quot;">​</a></h3><h3 id="页面置换算法" tabindex="-1">页面置换算法 <a class="header-anchor" href="#页面置换算法" aria-label="Permalink to &quot;页面置换算法&quot;">​</a></h3><h2 id="文件管理" tabindex="-1">文件管理 <a class="header-anchor" href="#文件管理" aria-label="Permalink to &quot;文件管理&quot;">​</a></h2><h3 id="文件管理-索引文件结构" tabindex="-1">文件管理 -- 索引文件结构 <a class="header-anchor" href="#文件管理-索引文件结构" aria-label="Permalink to &quot;文件管理 -- 索引文件结构&quot;">​</a></h3><h3 id="操作系统-文件和树型目录结构" tabindex="-1">操作系统 -- 文件和树型目录结构 <a class="header-anchor" href="#操作系统-文件和树型目录结构" aria-label="Permalink to &quot;操作系统 -- 文件和树型目录结构&quot;">​</a></h3><h3 id="文件管理-空闲存储空间管理" tabindex="-1">文件管理 -- 空闲存储空间管理 <a class="header-anchor" href="#文件管理-空闲存储空间管理" aria-label="Permalink to &quot;文件管理 -- 空闲存储空间管理&quot;">​</a></h3><h2 id="设备管理" tabindex="-1">设备管理 <a class="header-anchor" href="#设备管理" aria-label="Permalink to &quot;设备管理&quot;">​</a></h2><h3 id="数传输控制方式" tabindex="-1">数传输控制方式 <a class="header-anchor" href="#数传输控制方式" aria-label="Permalink to &quot;数传输控制方式&quot;">​</a></h3><h3 id="虚设备与spooling技术" tabindex="-1">虚设备与SPOOLING技术 <a class="header-anchor" href="#虚设备与spooling技术" aria-label="Permalink to &quot;虚设备与SPOOLING技术&quot;">​</a></h3><h2 id="围栏内核操作系统" tabindex="-1">围栏内核操作系统 <a class="header-anchor" href="#围栏内核操作系统" aria-label="Permalink to &quot;围栏内核操作系统&quot;">​</a></h2>',20);function q(i,f,x,g,k,C){const o=c("font");return r(),h("div",null,[e("h1",u,[a(n(i.$frontmatter.title)+" ",1),m,a(),_]),b,e("p",null,[a("进程前驱图（Process Precedence Diagram）是一种图形化工具，用于描述多个并发执行的进程之间的依赖关系和协作流程。"),s(o,{color:"#c02c38"},{default:d(()=>[a("它是一种有向无环图")]),_:1}),a("，其中每个节点代表一个进程，每条边表示进程间的先后执行顺序和依赖关系。")]),P])}const y=l(p,[["render",q]]);export{N as __pageData,y as default};
