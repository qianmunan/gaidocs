import{_ as c}from"./chunks/Iframe.5347c5e2.js";import{_ as r,o as m,c as u,z as l,a,t as h,G as t,B as n,V as e,D as d}from"./chunks/framework.055571f3.js";const L=JSON.parse('{"title":"数据结构基本概念","description":"","frontmatter":{"title":"数据结构基本概念"},"headers":[],"relativePath":"scattered/dataStruct/concept.md","filePath":"scattered/dataStruct/concept.md","lastUpdated":1683808633000}'),p={name:"scattered/dataStruct/concept.md"},_={id:"frontmatter-title",tabindex:"-1"},b=l("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),f=e("",7),k={class:"info custom-block"},x=l("p",{class:"custom-block-title"},"先听个音乐🎵",-1),g=e("",5),T=l("ol",null,[l("li",null,"集合：任何两个元素之间都没有逻辑关系，每个元素都是独立的"),l("li",null,"线性结构：结构中的元素之间存在一对一的关系。也就是说最前面的一个元素，后面有且只有一个元素。而最后面一个元素的前面，有且仅有一个元素。"),l("li",null,"树形结构：结构中的数据元素之间存在一对多的关系。可以想象为一棵倒立的树木。"),l("li",null,"图状结构：结构中的数据元素之间存在多对多的关系。")],-1),P=l("p",null,"总结：通常将集合，树形结构，图状结构归纳为非线性结构。因此数据的逻辑结构分为两大类，线性结构和非线性结构",-1),q=l("h3",{id:"数据的存储结构",tabindex:"-1"},[a("数据的存储结构 "),l("a",{class:"header-anchor",href:"#数据的存储结构","aria-label":'Permalink to "数据的存储结构"'},"​")],-1),y=l("ol",null,[l("li",null,"顺序存储：将数据元素依次存储于一组地址连续的存储单元中，元素间的逻辑关系由存储单元的位置直接体现，由此得出存储表示称为顺序存储结构"),l("li",null,"链式存储：将数据元素存储在一组任意的存储单元中，用附加的指针域表示元素之间的逻辑关系"),l("li",null,"索引存储：特点在存储数据元素的同时，还可以建立附加的索引表。索引表中的每一项称为索引项，索引项的格式为（关键字，地址），关键字是指能位移标识数据元素在索引表中均有一个索引项。"),l("li",null,"散列存储：用一个事先设计好的函数计算出该数据元素的存储地址，然后把它存入该地址中。")],-1),S=l("h3",{id:"数据运算",tabindex:"-1"},[a("数据运算 "),l("a",{class:"header-anchor",href:"#数据运算","aria-label":'Permalink to "数据运算"'},"​")],-1),O=l("h3",{id:"数据类型",tabindex:"-1"},[a("数据类型 "),l("a",{class:"header-anchor",href:"#数据类型","aria-label":'Permalink to "数据类型"'},"​")],-1),v=l("ol",null,[l("li",null,"原子类型：其值不可分解。C++中的基本数据类型（整型、字符型、枚举类型）、指针类型和空类型"),l("li",null,"结构类型：其值可分解成若干成分。比如C语言中的结构体")],-1),A=l("h3",{id:"抽象数据类型",tabindex:"-1"},[a("抽象数据类型 "),l("a",{class:"header-anchor",href:"#抽象数据类型","aria-label":'Permalink to "抽象数据类型"'},"​")],-1),V=l("p",null,"抽象数据类型（Abstract Data Type）：一个数学模型，以及定义在该模型上的一组操作。就是一个抽象的概念，是以数学模型为主体的，不依赖于内部的变化。",-1),C=e("",10),D=l("p",null,[a("时间复杂度是指算法的执行时间随着输入规模增加而增长的速度。通常用大O符号来表示，即"),l("p",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",null,[l("semantics",null,[l("mrow",null,[l("mi",null,"T"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,"="),l("mi",null,"O"),l("mo",null,"("),l("mi",null,"f"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,")")]),l("annotation",{encoding:"application/x-tex"},"T(n)=O(f(n))")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"strut",style:{height:"0.75em"}}),l("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"base textstyle uncramped"},[l("span",{class:"mord mathit",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mrel"},"="),l("span",{class:"mord mathit",style:{"margin-right":"0.02778em"}},"O"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mclose"},")")])])])]),a("，其中T(n)表示算法执行的时间，f(n)表示问题规模n的函数。一般情况下，我们会关注最坏情况下的时间复杂度，因为最坏情况下是算法执行最慢的情况，也是我们需要关注的。")],-1),I=l("p",null,"常见的时间复杂度有：",-1),N=l("ul",null,[l("li",null,"O(1)：常数时间复杂度，无论算法输入规模如何，算法执行的时间都保持不变。"),l("li",null,"O(log n)：对数时间复杂度，通常用于二分查找等问题，时间复杂度相对较低。"),l("li",null,"O(n)：线性时间复杂度，算法执行时间与输入规模呈线性关系。"),l("li",null,"O(n log n)：常见的排序算法如快速排序、归并排序等的时间复杂度。"),l("li",null,"O(n^2)：平方时间复杂度，通常用于简单排序算法如冒泡排序、插入排序等。"),l("li",null,"O(2^n)：指数时间复杂度，当算法要处理的数据集合中的数据元素个数非常大时，通常会出现这种复杂度。")],-1),$=l("ol",{start:"2"},[l("li",null,"空间复杂度")],-1),E=l("p",null,[a("空间复杂度是指算法所需内存空间随着输入规模增加而增长的速度。通常用大O符号来表示，即"),l("p",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",null,[l("semantics",null,[l("mrow",null,[l("mi",null,"S"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,"="),l("mi",null,"O"),l("mo",null,"("),l("mi",null,"f"),l("mo",null,"("),l("mi",null,"n"),l("mo",null,")"),l("mo",null,")")]),l("annotation",{encoding:"application/x-tex"},"S(n)=O(f(n))")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"strut",style:{height:"0.75em"}}),l("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"base textstyle uncramped"},[l("span",{class:"mord mathit",style:{"margin-right":"0.05764em"}},"S"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mrel"},"="),l("span",{class:"mord mathit",style:{"margin-right":"0.02778em"}},"O"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit",style:{"margin-right":"0.10764em"}},"f"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathit"},"n"),l("span",{class:"mclose"},")"),l("span",{class:"mclose"},")")])])])]),a("，其中S(n)表示算法占用的空间大小，f(n)表示问题规模n的函数。和时间复杂度类似，我们关注的也是最坏情况下的空间复杂度。")],-1),B=l("p",null,"常见的空间复杂度有：",-1),w=l("ul",null,[l("li",null,"O(1)：常数空间复杂度，算法所需空间为一个固定大小。"),l("li",null,"O(n)：线性空间复杂度，算法所需的空间与问题规模呈线性关系。"),l("li",null,"O(n^2)：平方空间复杂度，通常出现在需要使用二维数组或矩阵的算法中。")],-1),R=l("p",null,"总之，时间复杂度和空间复杂度都是衡量算法效率和优化的重要标准，开发者需要考虑算法的性质，根据实际场景来选择最合适的算法以提高执行效率和节省资源消耗。",-1);function z(i,G,J,U,j,F){const o=c,s=d("font");return m(),u("div",null,[l("h1",_,[a(h(i.$frontmatter.title)+" ",1),b]),f,l("div",k,[x,t(o,{mylink:"//music.163.com/outchain/player?type=2&id=1306923998&auto=1&height=66"})]),g,l("p",null,[a("数据的逻辑结构是从逻辑关系上描述数据，不涉及数据在计算机中的存储，"),t(s,{color:"red"},{default:n(()=>[a("是独立于计算机的")]),_:1}),a("。数据的逻辑结构是编程人员根据具体问题抽象出来的数学模型。其中在逻辑结构中有四种形式的逻辑关系。")]),T,P,q,l("p",null,[a("数据的存储结构是指数据在计算机内的表示方法，是逻辑结构在计算机中的具体实现。所以存储结构包含两个方面"),t(s,{color:"blue"},{default:n(()=>[a("数据元素的本身")]),_:1}),a("和"),t(s,{color:"blue"},{default:n(()=>[a("数据元素间逻辑的关系")]),_:1}),a("。")]),y,S,l("p",null,[a("数据运算是对数据施加的操作。每种逻辑结构都有一个基本运算的集合。可以简单理解为，对数据的增删改查。"),t(s,{color:"red"},{default:n(()=>[a("运算在逻辑结构上定义，在存储结构上实现")]),_:1}),a("。")]),O,v,A,V,l("p",null,[a("其构成为"),t(s,{color:"red"},{default:n(()=>[a("元素、关系、操作")]),_:1}),a("三种要素构成。")]),C,D,I,N,$,E,B,w,R])}const M=r(p,[["render",z]]);export{L as __pageData,M as default};
