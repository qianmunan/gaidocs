import{_ as e,o,c as r,z as t,a as c,t as i,V as n}from"./chunks/framework.c75b6473.js";const k=JSON.parse('{"title":"动作通信","description":"","frontmatter":{"title":"动作通信"},"headers":[],"relativePath":"ros/comm/actioncomm.md","lastUpdated":1681998807000}'),s={name:"ros/comm/actioncomm.md"},l={id:"frontmatter-title",tabindex:"-1"},d=t("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),h=n('<h2 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h2><p>关于action通信，我们先从之前导航中的应用场景开始介绍，描述如下：</p><blockquote><p>机器人导航到某个目标点,此过程需要一个节点A发布目标信息，然后一个节点B接收到请求并控制移动，最终响应目标达成状态信息。</p></blockquote><p>乍一看，这好像是服务通信实现，因为需求中要A发送目标，B执行并返回结果，这是一个典型的基于请求响应的应答模式，不过，如果只是使用基本的服务通信实现，存在一个问题：导航是一个过程，是耗时操作，如果使用服务通信，那么只有在导航结束时，才会产生响应结果，而在导航过程中，节点A是不会获取到任何反馈的，从而可能出现程序&quot;假死&quot;的现象，过程的不可控意味着不良的用户体验，以及逻辑处理的缺陷(比如:导航中止的需求无法实现)。更合理的方案应该是:导航过程中，可以连续反馈当前机器人状态信息，当导航终止时，再返回最终的执行结果。在ROS中，该实现策略称之为：action 通信。</p><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>动作通信适用于长时间运行的任务。就结构而言动作通信由目标、反馈和结果三部分组成；就功能而言动作通信类似于服务通信，动作客户端可以发送请求到动作服务端，并接收动作服务端响应的最终结果，不过动作通信可以在请求响应过程中获取连续反馈，并且也可以向动作服务端发送任务取消请求；就底层实现而言动作通信是建立在话题通信和服务通信之上的，目标发送实现是对服务通信的封装，结果的获取也是对服务通信的封装，而连续反馈则是对话题通信的封装。</p><div align="center"><img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/screenshot/ros2/action1.gif"></div><h2 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h2><p>一般适用于耗时的请求响应场景，用以获取连续的状态反馈。</p>',9);function m(a,_,p,u,f,b){return o(),r("div",null,[t("h1",l,[c(i(a.$frontmatter.title)+" ",1),d]),h])}const g=e(s,[["render",m]]);export{k as __pageData,g as default};
