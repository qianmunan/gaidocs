import{_ as e,o as l,c as p,z as s,a,t,V as i}from"./chunks/framework.055571f3.js";const g=JSON.parse('{"title":"栈","description":"","frontmatter":{"title":"栈"},"headers":[],"relativePath":"scattered/dataStruct/stack.md","filePath":"scattered/dataStruct/stack.md","lastUpdated":1686207654000}'),c={name:"scattered/dataStruct/stack.md"},r={id:"frontmatter-title",tabindex:"-1"},o=s("img",{src:"https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305170925458.png",width:"46",height:"46",alt:"图片描述",style:{display:"inline","margin-bottom":"-6px"}},null,-1),b=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}} <img src="https://gaidocs.oss-cn-hangzhou.aliyuncs.com/intenet/202305170925458.png" width="46" height="46" alt="图片描述" style="display:inline; margin-bottom: -6px"/>"'},"​",-1),u=i(`<div class="tip custom-block"><p class="custom-block-title">TIP</p><p>它的逻辑结构和线性表相同，但它是一种特殊的线性表，其特殊性在于运算操作受到了限制，因此栈又称为操作受限的线性表，栈是按照先进后出的规则进行操作。</p></div><h2 id="栈的定义和特点" tabindex="-1">栈的定义和特点 <a class="header-anchor" href="#栈的定义和特点" aria-label="Permalink to &quot;栈的定义和特点&quot;">​</a></h2><p>栈（Stack）是一种先进后出（Last-In-First-Out, LIFO）的数据结构，它可以看成是一种受限制的线性表，只允许在表的一端进行插入和删除操作。向栈中插入元素的操作称为入栈（Push），从栈中删除元素的操作称为出栈（Pop）。允许插入、删除的一端称为栈顶，栈顶的当前位置是动态变化的。不允许删除和插入的另一端称为栈底，栈底是固定不变的。当表中没有元素时称为空栈，站的插入运算称为进栈或入栈，栈的删除运算称为退栈。</p><p>栈有以下特点：</p><ol><li>栈是一种后进先出的数据结构，后加入的元素先被取出。</li><li>栈的操作受限，只允许在栈顶进行入栈和出栈操作。</li><li>栈可以用数组或链表实现，各有优缺点。数组实现简单高效，在空间上占用连续内存；链表实现灵活，不限定节点个数，但需要更多的存储空间和指针变量。</li><li>栈的基本操作包括初始化、判空、入栈、出栈、读取栈顶元素等。</li></ol><p>栈常用于算法中的递归调用、表达式求值、括号匹配、迷宫问题、深度优先搜索等场景。</p><h2 id="栈的工作原理" tabindex="-1">栈的工作原理 <a class="header-anchor" href="#栈的工作原理" aria-label="Permalink to &quot;栈的工作原理&quot;">​</a></h2><p>栈（Stack）的工作原理可以用以下几个步骤来描述：</p><ol><li>初始化一个空栈，即栈中没有任何元素。</li><li>当有元素要入栈时，先将栈顶指针加一，然后将新增元素放在栈顶处，完成入栈操作。</li><li>当需要出栈时，先将栈顶元素取出，并将栈顶指针减一，完成出栈操作。</li><li>在进行入栈或出栈操作时，需要判断栈是否已满或已空，以避免栈的上溢或下溢错误。</li><li>栈通常可以提供一些其他的操作，如读取栈顶元素、获取栈大小等。</li></ol><p>栈的本质是一个后进先出（Last-In-First-Out, LIFO）的线性数据结构。因此，栈的入栈和出栈操作只能在栈的末尾进行，即新元素永远都只能往栈顶添加，而只能从栈顶移除元素。通过栈顶指针来指示当前栈的位置，以便实现元素的入栈和出栈。</p><p>栈的工作原理相对简单，同时具有高效性，这使得它成为许多算法中的重要数据结构。</p><h2 id="栈的抽象数据类型" tabindex="-1">栈的抽象数据类型 <a class="header-anchor" href="#栈的抽象数据类型" aria-label="Permalink to &quot;栈的抽象数据类型&quot;">​</a></h2><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">ADT Stack{</span></span>
<span class="line"><span style="color:#e1e4e8;">    数据：存储栈的元素的数据结构;</span></span>
<span class="line"><span style="color:#e1e4e8;">    栈顶位置;</span></span>
<span class="line"><span style="color:#e1e4e8;">    栈的空间大小;</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">    操作;</span></span>
<span class="line"><span style="color:#e1e4e8;">    Stack(); // 构造了一个空栈</span></span>
<span class="line"><span style="color:#e1e4e8;">    ~Stack(); // 销毁一个已存在的栈</span></span>
<span class="line"><span style="color:#e1e4e8;">    Empty_Stack(); // 判断栈是否为空</span></span>
<span class="line"><span style="color:#e1e4e8;">    Push_Stack(); // 将元素e插入栈顶</span></span>
<span class="line"><span style="color:#e1e4e8;">    Pop_Stack(&amp;e); // 从栈顶删除一个元素到e中返回</span></span>
<span class="line"><span style="color:#e1e4e8;">    GetTop_Stack(&amp;e); // 从栈顶取出一个元素到e中返回</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="栈的存储方法及基本操作" tabindex="-1">栈的存储方法及基本操作 <a class="header-anchor" href="#栈的存储方法及基本操作" aria-label="Permalink to &quot;栈的存储方法及基本操作&quot;">​</a></h2><p>栈是一种线性数据结构，它的存储方式有两种：数组存储和链表存储。</p><p>数组存储方式：使用数组作为栈的存储空间，将栈顶指针指向数组的最后一个元素，栈底指针指向数组的第一个元素。</p><p>链表存储方式：使用链表作为栈的存储空间，每个节点包含一个数据元素和一个指向下一个节点的指针，栈顶指针指向链表的第一个节点。</p><p>栈的基本操作包括：</p><ol><li>初始化操作：创建一个空栈。</li><li>入栈操作：将元素压入栈顶，同时栈顶指针加1。</li><li>出栈操作：从栈顶弹出一个元素，同时栈顶指针减1。</li><li>取栈顶元素操作：返回栈顶元素的值，但不删除该元素。</li><li>判断栈是否为空操作：判断栈顶指针是否等于栈底指针。</li><li>判断栈是否已满操作（仅适用于数组存储方式）：判断栈顶指针是否等于数组的长度减1。</li><li>清空栈操作：将栈清空，即将栈顶指针回到栈底位置。</li></ol><p>以上是栈的基本操作，它们是栈实现各种高级操作的基础。</p><h2 id="栈存储的优缺点" tabindex="-1">栈存储的优缺点 <a class="header-anchor" href="#栈存储的优缺点" aria-label="Permalink to &quot;栈存储的优缺点&quot;">​</a></h2><p>栈是一种后进先出（LIFO）的数据结构，存储分配采用连续方式，可以使用数组或链表来实现。栈具有以下优点和缺点：</p><p>优点：</p><ol><li>存储操作非常简单，只需在栈顶进行插入和删除操作；</li><li>只要栈不满，就能够快速地把数据压入栈中，并在需要时弹出；</li><li>由于存储采用连续内存，CPU访问起来相对简单，栈的效率高于链式存储结构。</li></ol><p>缺点：</p><ol><li>栈的容量通常较小，在存储大量数据时需要考虑溢出问题；</li><li>如果栈没有被及时回收，会出现内存泄漏的问题，尤其在递归调用中，每个函数调用都会占用一部分栈空间；</li><li>由于栈的后进先出原则，无法随机访问栈中的元素，因此需要依次弹出栈中的元素来获取所需的数据。</li></ol><p>总体而言，栈适用于一些临时存储并轻量级的业务场景，如计算器、括号匹配等，但如果需要存储大量数据或者需要灵活地访问其中的元素，则不建议使用栈。</p><h2 id="顺序栈" tabindex="-1">顺序栈 <a class="header-anchor" href="#顺序栈" aria-label="Permalink to &quot;顺序栈&quot;">​</a></h2><p>栈的存储与一般的线性表的存储类似，只要有两种存储形式：顺序存储和链式存储。</p><p>顺序栈是一种基于数组实现的栈，也称作数组栈。其操作方式与其他栈数据结构相同，只能在栈顶执行插入、删除等操作，并且具有后进先出（LIFO）的特性。</p><p>顺序栈主要涉及容量和栈顶指针两个关键概念。容量表示可用于存储元素的最大数量，而栈顶指针通常指向栈中最前面的元素。在顺序栈中，插入和删除操作通常可以通过增加或减少栈顶指针来实现。</p><h3 id="顺序栈的类描述" tabindex="-1">顺序栈的类描述 <a class="header-anchor" href="#顺序栈的类描述" aria-label="Permalink to &quot;顺序栈的类描述&quot;">​</a></h3><div class="language-c++ line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">typedef int DtataType; // 这里以整形为栈的数据类型</span></span>
<span class="line"><span style="color:#e1e4e8;">class SeqStack{</span></span>
<span class="line"><span style="color:#e1e4e8;">    private:</span></span>
<span class="line"><span style="color:#e1e4e8;">        DataType *base; // 栈底指针</span></span>
<span class="line"><span style="color:#e1e4e8;">        DataType *top; // 栈顶指针始终指向栈顶元素的最后一个位置</span></span>
<span class="line"><span style="color:#e1e4e8;">        int size; // 栈的大小</span></span>
<span class="line"><span style="color:#e1e4e8;">    public:</span></span>
<span class="line"><span style="color:#e1e4e8;">    	SeqStack(int stacksize = 100){ </span></span>
<span class="line"><span style="color:#e1e4e8;">            base = new DataType[stacksize]; </span></span>
<span class="line"><span style="color:#e1e4e8;">            top = base; // 指向栈顶元素的后一位置</span></span>
<span class="line"><span style="color:#e1e4e8;">            size = stacksize; // 构造了一个空栈，默认大小为100个单元</span></span>
<span class="line"><span style="color:#e1e4e8;">        };</span></span>
<span class="line"><span style="color:#e1e4e8;">    	~SeqStack(){</span></span>
<span class="line"><span style="color:#e1e4e8;">            deletep[] base;</span></span>
<span class="line"><span style="color:#e1e4e8;">            top = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">            base = NULL;</span></span>
<span class="line"><span style="color:#e1e4e8;">        }; // 销毁一个已存在的栈</span></span>
<span class="line"><span style="color:#e1e4e8;">    	int Empty_Stack(); // 判断栈是否为空</span></span>
<span class="line"><span style="color:#e1e4e8;">    	int Push_Stack(DataType e); // 将元素e插入栈顶</span></span>
<span class="line"><span style="color:#e1e4e8;">    	int Pop_Stack(DataType &amp;e);</span></span>
<span class="line"><span style="color:#e1e4e8;">    	</span></span>
<span class="line"><span style="color:#e1e4e8;">    </span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div>`,33);function d(n,m,h,y,k,_){return l(),p("div",null,[s("h1",r,[a(t(n.$frontmatter.title)+" ",1),o,a(),b]),u])}const f=e(c,[["render",d]]);export{g as __pageData,f as default};
